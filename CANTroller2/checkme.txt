diff --git a/CANTroller2/src/RunModeManager.h b/CANTroller2/src/RunModeManager.h
index 96fde7f..84f7491 100644
--- a/CANTroller2/src/RunModeManager.h
+++ b/CANTroller2/src/RunModeManager.h
@@ -1,5 +1,5 @@
 #pragma once
-class RunModeManager {
+class RunModeManager {  // Runmode state machine. Gas/brake control targets are determined here.  - takes 36 us in shutdown mode with no activity
   private:
     int _joydir;
     float cruise_ctrl_extent_pc, adjustpoint;       // During cruise adjustments, saves farthest trigger position read
@@ -8,41 +8,36 @@ class RunModeManager {
     static const uint32_t motor_park_timeout_us = 4000000;        // Time allowed for joy mode-change gesture motions (Fly mode <==> Cruise mode) (in us)
     static const uint32_t sleep_inactivity_timeout_us = 180000000;        // Time allowed for joy mode-change gesture motions (Fly mode <==> Cruise mode) (in us)
     Timer gestureFlyTimer, cruiseDeltaTimer, pwrup_timer, motor_park_timer, sleep_inactivity_timer;
-    runmode _currentMode = SHUTDOWN; // note these are more here in caseA we eventually don't use the globals
-    runmode _oldMode;
     uint32_t pwrup_timeout = 500000;
     Encoder* encoder;
     Display* display;
+    int oldmode;
+    bool autostopping_last = false;
   public:
-    // Call this function in the main loop to manage run modes
-    // Runmode state machine. Gas/brake control targets are determined here.  - takes 36 us in shutdown mode with no activity
+    int mode = SHUTDOWN;
+    bool we_just_switched_modes = true;  // For mode logic to set things up upon first entry into mode
+    bool joy_centered = false;  // minor state variable for hold mode
+    bool flycruise_toggle_request = false;
     RunModeManager(Display* _display, Encoder* _encoder) {
-        encoder = _encoder;
         display = _display;
+        encoder = _encoder;
         motor_park_timer.set(motor_park_timeout_us);
     }
-    runmode go_to(runmode newmode) {
-        _currentMode = newmode;
-        return newmode;
-    }
-    runmode mode() { return _currentMode; }
-    runmode* mode_ptr() { return &_currentMode; }
-
-    runmode run_runmode() {
+    int run_runmode() {
         updateMode(); // Update the current mode if needed, this also sets we_just_switched_modes
-        if (_currentMode == BASIC) run_basicMode(); // Basic mode is for when we want to operate the pedals manually. All PIDs stop, only steering still works.
-        else if (_currentMode == ASLEEP) run_asleepMode();
-        else if (_currentMode == SHUTDOWN) run_shutdownMode();
-        else if (_currentMode == STALL) run_stallMode();
-        else if (_currentMode == HOLD) run_holdMode();
-        else if (_currentMode == FLY) run_flyMode();
-        else if (_currentMode == CRUISE) run_cruiseMode();
-        else if (_currentMode == CAL) run_calMode();
+        if (mode == BASIC) run_basicMode(); // Basic mode is for when we want to operate the pedals manually. All PIDs stop, only steering still works.
+        else if (mode == ASLEEP) run_asleepMode();
+        else if (mode == SHUTDOWN) run_shutdownMode();
+        else if (mode == STALL) run_stallMode();
+        else if (mode == HOLD) run_holdMode();
+        else if (mode == FLY) run_flyMode();
+        else if (mode == CRUISE) run_cruiseMode();
+        else if (mode == CAL) run_calMode();
         else {  // Obviously this should never happen
             Serial.println (F("Error: Invalid runmode entered"));
-            go_to(SHUTDOWN);
+            mode = SHUTDOWN;
         }
-        return _currentMode;
+        return mode;
     }
   private:
     bool autostop(req _cmd = req_na) {
@@ -94,40 +89,40 @@ class RunModeManager {
     //     esp_deep_sleep_start();
     // }
     void updateMode() {
-        if (basicmodesw) _currentMode = BASIC;  // if basicmode switch on --> Basic Mode
-        else if ((_currentMode != CAL) && (_currentMode != ASLEEP)) {
-            if (panicstop || !ignition) _currentMode = SHUTDOWN;
-            else if (tach.engine_stopped()) _currentMode = STALL;;  // otherwise if engine not running --> Stall Mode
+        if (basicmodesw) mode = BASIC;  // if basicmode switch on --> Basic Mode
+        else if ((mode != CAL) && (mode != ASLEEP)) {
+            if (panicstop || !ignition) mode = SHUTDOWN;
+            else if (tach.engine_stopped()) mode = STALL;;  // otherwise if engine not running --> Stall Mode
         }
-        we_just_switched_modes = (_currentMode != _oldMode);  // currentMode should not be changed after this point in loop
+        we_just_switched_modes = (mode != oldmode);  // currentMode should not be changed after this point in loop
         if (we_just_switched_modes) {
             disp_runmode_dirty = true;
             cleanup_state_variables();
         }
-        _oldMode = _currentMode;
+        oldmode = mode;
     }
     void cleanup_state_variables()  {
-        if (_oldMode == BASIC) park_motors(req_off);
-        else if (_oldMode == ASLEEP) powering_up = false;
-        else if (_oldMode == SHUTDOWN) {
+        if (oldmode == BASIC) park_motors(req_off);
+        else if (oldmode == ASLEEP) powering_up = false;
+        else if (oldmode == SHUTDOWN) {
             autostop(req_off);
             park_motors(req_off);
             shutdown_incomplete = false;
         }
-        else if (_oldMode == STALL);
-        else if (_oldMode == HOLD) {
+        else if (oldmode == STALL);
+        else if (oldmode == HOLD) {
             autostop(req_off);
             joy_centered = false;
             starter_request = req_off;  // Stop any in-progress startings
         }
-        else if (_oldMode == FLY) car_hasnt_moved = false;
-        else if (_oldMode == CRUISE) cruise_adjusting = false;
-        else if (_oldMode == CAL) cal_pot_gasservo_ready = cal_pot_gasservo_mode = cal_joyvert_brkmotor_mode = false;
+        else if (oldmode == FLY) car_hasnt_moved = false;
+        else if (oldmode == CRUISE) cruise_adjusting = false;
+        else if (oldmode == CAL) cal_pot_gasservo_ready = cal_pot_gasservo_mode = cal_joyvert_brkmotor_mode = false;
     }
     void run_basicMode() { // Basic mode is for when we want to operate the pedals manually. All PIDs stop, only steering still works.
         if (we_just_switched_modes) park_motors(req_on);  // Upon entering basic mode, the brake and gas actuators need to be parked out of the way so the pedals can be used.
         else if (park_the_motors) park_motors();  // Update motor parking until finished
-        if (!basicmodesw && !tach.engine_stopped()) go_to( speedo.car_stopped() ? HOLD : FLY );  // If we turned off the basic mode switch with engine running, change modes. If engine is not running, we'll end up in Stall Mode automatically
+        if (!basicmodesw && !tach.engine_stopped()) mode = speedo.car_stopped() ? HOLD : FLY;  // If we turned off the basic mode switch with engine running, change modes. If engine is not running, we'll end up in Stall Mode automatically
     }
     void run_asleepMode() {  // turns off syspower and just idles. sleep_request are handled here or in shutdown mode below
         if (we_just_switched_modes) {
@@ -142,8 +137,8 @@ class RunModeManager {
             powering_up = true;
         }
         if (powering_up && pwrup_timer.expired()) {
-            display->all_dirty();
-            go_to(SHUTDOWN);
+            display->all_dirty();  // tells display to redraw everything. display must set back to false
+            mode = SHUTDOWN;
         }
     }
     void run_shutdownMode() { // In shutdown mode we stop the car if it's moving, park the motors, go idle for a while and eventually sleep.
@@ -161,33 +156,33 @@ class RunModeManager {
             if (!shutdown_incomplete) sleep_inactivity_timer.reset();  // upon shutdown completion, start the sleep timer
         }
         else {  // if shutdown is complete
-            if (calmode_request) go_to(CAL);  // if fully shut down and cal mode requested, go to cal mode
-            if (sleep_inactivity_timer.expired() || sleep_request == req_on) go_to(ASLEEP);
+            if (calmode_request) mode = CAL;  // if fully shut down and cal mode requested, go to cal mode
+            if (sleep_inactivity_timer.expired() || sleep_request == req_on) mode = ASLEEP;
         }
         sleep_request == req_na;
-        if ((speedo.car_stopped() || allow_rolling_start) && ignition && !panicstop && !tach.engine_stopped()) go_to(HOLD);  // If we started the car, go to Hold mode. If ignition is on w/o engine running, we'll end up in Stall Mode automatically
+        if ((speedo.car_stopped() || allow_rolling_start) && ignition && !panicstop && !tach.engine_stopped()) mode = HOLD;  // If we started the car, go to Hold mode. If ignition is on w/o engine running, we'll end up in Stall Mode automatically
     }
     void run_stallMode() {  // In stall mode, the gas doesn't have feedback, so runs open loop, and brake pressure target proportional to joystick
         if (hotrc.joydir(vert) != joy_down) brake.pid.set_target(pressure.min_human());  // If in deadband or being pushed up, no pressure target
         else brake.pid.set_target(map (hotrc.pc[vert][filt], hotrc.pc[vert][dbbot], hotrc.pc[vert][opmin], pressure.min_human(), pressure.max_human()));  // Scale joystick value to pressure adc setpoint
-        if (starter || !tach.engine_stopped()) go_to(HOLD);  // If we started the car, enter hold mode once starter is released
+        if (starter || !tach.engine_stopped()) mode = HOLD;  // If we started the car, enter hold mode once starter is released
     }
     void run_holdMode() {
         if (we_just_switched_modes) joy_centered = false;  // Fly mode will be locked until the joystick first is put at or below center
         if (!speedo.car_stopped()) autostop(req_on);
         throttle.goto_idle();  // Let off gas (if gas using PID mode) and keep target updated to possibly changing idle value
         if (hotrc.joydir(vert) != joy_up) joy_centered = true; // Mark joystick at or below center, now pushing up will go to fly mode
-        else if (joy_centered && !starter && !hotrc.radiolost()) go_to(FLY); // Enter Fly Mode upon joystick movement from center to above center  // Possibly add "&& car_stopped()" to above check?
+        else if (joy_centered && !starter && !hotrc.radiolost()) mode = FLY; // Enter Fly Mode upon joystick movement from center to above center  // Possibly add "&& car_stopped()" to above check?
     }
     void run_flyMode() {
         if (we_just_switched_modes) car_hasnt_moved = speedo.car_stopped();  // note whether car is moving going into fly mode (probably not), this turns true once it has initially got moving
         _joydir = hotrc.joydir(vert);
         if (car_hasnt_moved) {
-            if (_joydir != joy_up) go_to(HOLD);  // Must keep pulling trigger until car moves, or it drops back to hold mode
+            if (_joydir != joy_up) mode = HOLD;  // Must keep pulling trigger until car moves, or it drops back to hold mode
             else if (!speedo.car_stopped()) car_hasnt_moved = false;  // Once car moves, we're allowed to release the trigger without falling out of fly mode
         }
-        else if (speedo.car_stopped() && hotrc.joydir() != joy_up) go_to(HOLD);  // Go to Hold Mode if we have come to a stop after moving  // && hotrc.pc[vert][filt] <= hotrc.pc[vert][dbbot]
-        if (!sim.simulating(sens::joy) && hotrc.radiolost()) go_to(HOLD);  // Radio must be good to fly. This should already be handled elsewhere but another check can't hurt
+        else if (speedo.car_stopped() && hotrc.joydir() != joy_up) mode = HOLD;  // Go to Hold Mode if we have come to a stop after moving  // && hotrc.pc[vert][filt] <= hotrc.pc[vert][dbbot]
+        if (!sim.simulating(sens::joy) && hotrc.radiolost()) mode = HOLD;  // Radio must be good to fly. This should already be handled elsewhere but another check can't hurt
         else {  // Update the gas and brake targets based on joystick position, for the PIDs to drive
             if (_joydir == joy_up)  // If we are trying to accelerate, scale joystick value to determine gas setpoint
                 gas.pid.set_target(map(hotrc.pc[vert][filt], hotrc.pc[vert][dbtop], hotrc.pc[vert][opmax], throttle.idle_rpm, tach.govern_rpm()));
@@ -197,7 +192,7 @@ class RunModeManager {
                 brake.pid.set_target(map(hotrc.pc[vert][filt], hotrc.pc[vert][dbbot], hotrc.pc[vert][opmin], pressure.min_human(), pressure.max_human()));
             else brake.pid.set_target(pressure.min_human());  // Else let off the brake   
         }
-        if (flycruise_toggle_request) go_to(CRUISE);  // enter cruise mode by pressing hrc ch4 button
+        if (flycruise_toggle_request) mode = CRUISE;  // enter cruise mode by pressing hrc ch4 button
         flycruise_toggle_request = false;
     }
     void run_cruiseMode() {
@@ -216,7 +211,7 @@ class RunModeManager {
             cruise_trigger_released = true;
             cruise_ctrl_extent_pc = hotrc.pc[vert][cent];  // After an adjustment, need this to prevent setpoint from following the trigger back to center as you release it
         }
-        else if (_joydir == joy_down && !cruise_speed_lowerable) go_to(FLY);
+        else if (_joydir == joy_down && !cruise_speed_lowerable) mode = FLY;
         else if (cruise_trigger_released) {  // adjustments disabled until trigger has been to center at least once since going to cruise mode
             float ctrlratio = (std::abs(hotrc.pc[vert][filt]) - hotrc.pc[vert][dbtop]) / (hotrc.pc[vert][opmax] - hotrc.pc[vert][dbtop]);
             if (cruise_setpoint_mode == throttle_delta) {
@@ -237,16 +232,16 @@ class RunModeManager {
             gas.cruise_target_pc = constrain(gas.cruise_target_pc, 0.0, 100.0);
             cruise_adjusting = true;
         }
-        if (flycruise_toggle_request) go_to(FLY);  // Go to fly mode if hotrc ch4 button pushed
+        if (flycruise_toggle_request) mode = FLY;  // Go to fly mode if hotrc ch4 button pushed
         flycruise_toggle_request = false;
         // If joystick is held full-brake for more than X, driver could be confused & panicking, drop to fly mode so fly mode will push the brakes
         if (hotrc.pc[vert][filt] > hotrc.pc[vert][opmin] + flycruise_vert_margin_pc) gestureFlyTimer.reset();  // Keep resetting timer if joystick not at bottom
-        else if (gestureFlyTimer.expired()) go_to(FLY);  // New gesture to drop to fly mode is hold the brake all the way down for more than X ms
-        if (speedo.car_stopped()) go_to((_joydir == joy_up) ? FLY : HOLD);  // In case we slam into camp Q woofer stack, get out of cruise mode.
+        else if (gestureFlyTimer.expired()) mode = FLY;  // New gesture to drop to fly mode is hold the brake all the way down for more than X ms
+        if (speedo.car_stopped()) mode = (_joydir == joy_up) ? FLY : HOLD;  // In case we slam into camp Q woofer stack, get out of cruise mode.
     }
     void run_calMode() {  // Calibration mode is purposely difficult to get into, because it allows control of motors without constraints for purposes of calibration. Don't use it unless you know how.
         if (we_just_switched_modes) calmode_request = cal_pot_gasservo_mode = cal_pot_gasservo_ready = cal_joyvert_brkmotor_mode = false;
-        else if (calmode_request) go_to(SHUTDOWN);
+        else if (calmode_request) mode = SHUTDOWN;
         float temp = pot.mapToRange(0.0, 180.0);
         cal_pot_gasservo_ready = (temp >= gas.nat[parked] && temp <= gas.nat[opmax]);
     }
diff --git a/CANTroller2/src/cantroller2.cpp b/CANTroller2/src/cantroller2.cpp
index 68b2462..c62c267 100755
--- a/CANTroller2/src/cantroller2.cpp
+++ b/CANTroller2/src/cantroller2.cpp
@@ -1,21 +1,22 @@
 // Carpet CANTroller II  Source Code  - For ESP32-S3-DevKitC-1-N8
-#include "common.h"
+#include "globals.h"
 #include "uictrl.h"
 #include "mapsens.h"
 #include "sensors.h"
 #include "temperature.h"
 #include "motors.h"
 #include "neopixel.h"
-#include "globals.h"
+#include "objects.h"
 #include "display.h"
 #include "touch.h"
 #include "RunModeManager.h"
 #include "freertos/FreeRTOS.h"
 #include "freertos/task.h"
-Display screen;
-TouchScreen touch(touch_cs_pin);
-RunModeManager run(&screen, &encoder);
-ESP32PWM pwm;  // Object for timer pwm resources (servo outputs)
+static Display screen;
+static TouchScreen touch(touch_cs_pin);
+static RunModeManager run(&screen, &encoder);
+
+static ESP32PWM pwm;  // Object for timer pwm resources (servo outputs)
 void get_touchpoint() { 
     touch_pt[0] = touch.touch_pt(0);
     touch_pt[1] = touch.touch_pt(1); 
@@ -35,15 +36,15 @@ void neo_idiots_update() {
         }
     }
 }
-void hotrc_events_update(int8_t _rm) {
+void hotrc_events_update() {
     hotrc.toggles_update();
     if (hotrc.sw_event(ch3)) ignition_request = req_tog;  // Turn on/off the vehicle ignition. If ign is turned off while the car is moving, this leads to panic stop
     if (hotrc.sw_event(ch4)) {
-        if (_rm == FLY || _rm == CRUISE) flycruise_toggle_request = true;
-        else if (_rm == STALL) starter_request = req_tog;
-        else if (_rm == HOLD) starter_request = req_off;
-        else if (_rm == SHUTDOWN && !shutdown_incomplete) sleep_request = req_on;
-        else if (_rm == ASLEEP) sleep_request = req_off; 
+        if (run.mode == FLY || run.mode == CRUISE) run.flycruise_toggle_request = true;
+        else if (run.mode == STALL) starter_request = req_tog;
+        else if (run.mode == HOLD) starter_request = req_off;
+        else if (run.mode == SHUTDOWN && !shutdown_incomplete) sleep_request = req_on;
+        else if (run.mode == ASLEEP) sleep_request = req_off; 
     }
     hotrc.toggles_reset();
 }
@@ -71,7 +72,7 @@ void setup() {  // Setup just configures pins (and detects touchscreen type)
     write_pin(syspower_pin, syspower);
     set_pin(uart_tx_pin, INPUT);  // UART:  1st detect breadboard vs. vehicle PCB using TX pin pullup, then repurpose pin for UART and start UART 
     running_on_devboard =(read_pin(uart_tx_pin));
-    set_board_defaults(running_on_devboard);
+    set_board_defaults();
     set_pin(uart_tx_pin, OUTPUT);  // 
     Serial.begin(115200);  // Open console serial port
     delay(800);  // This is needed to allow the uart to initialize and the screen board enough time after a cold boot
@@ -139,7 +140,6 @@ void setup() {  // Setup just configures pins (and detects touchscreen type)
 }
 void loop() {
     ignition_panic_update();  // handler for ignition pin output and panicstop status.
-    bootbutton_update();
     basicsw_update();
     starter_update();  // Runs starter bidirectional handler
     encoder.update();  // Read encoder input signals
@@ -155,22 +155,22 @@ void loop() {
     mapsens.update();  // MAP sensor  // takes 6800 us (!!)
     maf_gps = massairflow();  // Recalculate intake mass airflow
     if (touch_reticles) get_touchpoint();
-    hotrc_events_update(run.mode());
+    hotrc_events_update();
     hotrc.update();
     run.run_runmode();  // Runmode state machine. Gas/brake control targets are determined here.  - takes 36 us in shutdown mode with no activity
-    gas.update(run.mode());
-    brake.update(run.mode());
-    steer.update(run.mode());
+    gas.update(run.mode);
+    brake.update(run.mode);
+    steer.update(run.mode);
     if (sim.potmapping(sens::joy)) hotrc.set_pc(horz, filt, pot.mapToRange(steer.pc_to_us(steer.pc[opmin]), steer.pc_to_us(steer.pc[opmax])));
     touch.update(); // Handle touch events and actions
     if (screensaver && touch.touched()) screen.saver_touch(touch.touch_pt(0), touch.touch_pt(1));
-    tuner_update(run.mode());
+    tuner_update(run.mode);
     diag_update();  // notice any screwy conditions or suspicious shenigans
     neo_idiots_update();
-    neo.set_heartcolor(colorcard[run.mode()]);
+    neo.set_heartcolor(colorcard[run.mode]);
     neo.update(!syspower);
     looptime_mark("-");
-    screen.update(run.mode());  // Display updates
+    screen.update(run.mode);  // Display updates
     if (!display_enabled && datapage_last != datapage) config.putUInt("dpage", datapage);
     looptime_mark("dis");
     looptime_update();
diff --git a/CANTroller2/src/common.h b/CANTroller2/src/common.h
deleted file mode 100644
index 90ffedd..0000000
--- a/CANTroller2/src/common.h
+++ /dev/null
@@ -1,291 +0,0 @@
-// Contains utility functions, classes, and defines
-#pragma once
-#include <Wire.h>
-#include "Arduino.h"
-// #include <cstdint> // for uint types
-// #include <cstdio> // for printf
-// pin assignments  ESP32-S3-DevkitC series
-#define      button_pin  0 // button0/strap-1  // Input, Rotary encoder push switch, for the UI. active low (needs pullup). Also the esp "Boot" button does the same thing
-#define    lipobatt_pin  1 // adc1ch0          // Analog input, LiPo cell voltage, full scale is 4.8V
-#define   encoder_b_pin  2 // adc1ch1          // Int input, The B (aka DT) pin of the encoder. Both A and B complete a negative pulse in between detents. If B pulse goes low first, turn is CW. (needs pullup)
-#define      tft_dc_pin  3 // adc1ch2/strap-X  // Output, Assert when sending data to display chip to indicate commands vs. screen data - ! pin is also defined in tft_setup.h
-#define    mulebatt_pin  4 // adc1ch3          // Analog input, mule battery voltage sense, full scale is 16V
-#define    pot_wipe_pin  5 // adc1ch4          // Analog in from 20k pot
-#define   brake_pos_pin  6 // adc1ch5          // Analog input, tells us linear position of brake actuator. Blue is wired to ground, POS is wired to white.
-#define    pressure_pin  7 // adc1ch6          // Analog input, tells us brake fluid pressure. Needs a R divider to scale max possible pressure (using foot) to 3.3V.
-#define     i2c_sda_pin  8 // i2c0sda/adc1ch7  // i2c bus for airspeed/map sensors, lighting board, cap touchscreen
-#define     i2c_scl_pin  9 // i2c0scl/adc1ch8  // i2c bus for airspeed/map sensors, lighting board, cap touchscreen
-#define      tft_cs_pin 10 // spi0cs/adc1ch9   // Output, active low, Chip select allows ILI9341 display chip use of the SPI bus - ! pin is also defined in tft_setup.h
-#define    spi_mosi_pin 11 // spi0mosi/adc2ch0 // Used as spi interface data for touchscreen, sd card and tft screen - ! pin is also defined in tft_setup.h
-#define    spi_sclk_pin 12 // spi0sclk/adc2ch1 // Used as spi interface clock for touchscreen, sd card and tft screen - ! pin is also defined in tft_setup.h
-#define    spi_miso_pin 13 // spi0miso/adc2ch2 // Used as spi interface data from sd card and possibly (?) tft screen - ! pin is also defined in tft_setup.h
-#define hotrc_ch2_v_pin 14 // pwm0/adc2ch3     // Hotrc Ch2 bidirectional trigger input
-#define hotrc_ch1_h_pin 15 // pwm1/adc2ch4     // Hotrc Ch1 thumb joystick input
-#define     gas_pwm_pin 16 // pwm1/adc2ch5     // Output, PWM signal duty cycle controls throttle target. On Due this is the pin labeled DAC1 (where A13 is on Mega)
-#define   brake_pwm_pin 17 // pwm0/adc2ch6/tx1 // Output, PWM signal duty cycle sets speed of brake actuator from full speed extend to full speed retract, (50% is stopped)
-#define   steer_pwm_pin 18 // pwm0/adc2ch7/rx1 // Output, PWM signal positive pulse width sets steering motor speed from full left to full speed right, (50% is stopped). Jaguar asks for an added 150ohm series R when high is 3.3V
-#define steer_enc_a_pin 19 // usb-d-/adc2ch8   // Reserved for a steering quadrature encoder. Encoder "A" signal
-#define steer_enc_b_pin 20 // usb-d+/adc2ch9   // Reserved for a steering quadrature encoder. Encoder "B" signal
-#define     onewire_pin 21 // pwm0             // Onewire bus for temperature sensor data. note: tested this does not work on higher-numbered pins (~35+)
-#define      speedo_pin 35 // spiram/octspi    // Int Input, active high, asserted when magnet South is in range of sensor. 1 pulse per driven pulley rotation. (Open collector sensors need pullup)
-#define     starter_pin 36 // sram/ospi/glitch // Input/Output (both active high), output when starter is being driven, otherwise input senses external starter activation
-#define        tach_pin 37 // spiram/octspi    // Int Input, active high, asserted when magnet South is in range of sensor. 1 pulse per engine rotation. (no pullup) - Note: placed on p36 because filtering should negate any effects of 80ns low pulse when certain rtc devices power on (see errata 3.11)
-#define   sdcard_cs_pin 38 // spiram/octspi    // Output, chip select for SD card controller on SPI bus
-#define basicmodesw_pin 39 // jtck/glitch      // Input, asserted to tell us to run in basic mode, active low (has ext pullup) - Note: placed on p39 because filtering should negate any effects of 80ns low pulse when certain rtc devices power on (see errata 3.11)
-#define   hotrc_ch4_pin 40 // jtdo             // Syspower, starter, and cruise mode toggle control. Hotrc Ch4 PWM toggle signal
-#define   hotrc_ch3_pin 41 // jtdi             // Ignition control, Hotrc Ch3 PWM toggle signal
-#define   encoder_a_pin 42 // jtms             // Int input, The A (aka CLK) pin of the encoder. Both A and B complete a negative pulse in between detents. If A pulse goes low first, turn is CCW. (needs pullup)
-#define     uart_tx_pin 43 // "TX"/uart0tx     // Serial monitor data out. Also used to detect devboard vs. pcb at boot time (using pullup/pulldown, see below)
-#define     uart_rx_pin 44 // "RX"/uart0rx     // Serial monitor data in. Maybe could repurpose during runtime since we only need outgoing console data?
-#define    ignition_pin 45 // strap-0          // Output to an nfet/pfet pair to control the car ignition
-#define    syspower_pin 46 // strap-0          // Output to an nfet/pfet pair to power all the tranducers.
-#define    touch_cs_pin 47 // NA               // Output, chip select for resistive touchscreen, active low - ! pin is also defined in tft_setup.h
-#define    neopixel_pin 48 // neopix           // Data line to onboard Neopixel WS281x (on all v1 devkit boards - pin 38 is used on v1.1 boards). Also used for onboard and external neopoxels - ! pin is also defined in neopixel.h
-// External components needed (pullup/pulldown resistors, capacitors, etc.): (Note: "BB" = On dev breadboards only, "PCB" = On vehicle PCB only)
-// 1. brake_pos_pin: Add 1M-ohm to GND. Allows detecting unconnected sensor or broken connection.
-// 2. onewire_pin: Add 4.7k-ohm to 3.3V. Needed for open collector sensor output, to define logic-high voltage level.
-// 3. tach_pin, speedo_pin: (PCB) Add 4.7k-ohm to 3.3V. For open collector sensor outputs. (BB) If no sensor is present: connect 4.7k-ohm to GND instead. Allows sensor detection.
-// 4. neopixel_pin: (PCB) Add 330 ohm in series (between pin and the DataIn pin of the 1st pixel). (BB) Same, but this one is likely optional, e.g. mine works w/o it.  For signal integrity over long wires. 
-// 5. uart_tx_pin: (PCB) Add 22k-ohm to GND. (BB) Connect the 22k-ohm to 3.3V instead. For boot detection of vehicle PCB, so defaults are set appropriately.
-// 6. ADC inputs (mulebatt_pin, pressure_pin, brake_pos_pin, pot_wipe_pin) should have 100nF cap to gnd, tho it works w/o it.
-// 7. encoder_a_pin, encoder_b_pin, button_pin: should have 10nF to gnd, tho it should work w/o it. Pullups to 3.3V (4.7k-ohm is good) are also necessary, but the encoder we're using includes these.
-// 8. Resistor dividers are needed for these inputs: starter_pin (16V->3.3V), mulebatt_pin (16V->3.3V), and pressure_pin (5V->3.3V).
-// 9. ignition_pin, syspower_pin, starter_pin: require pulldowns to gnd, this is provided by nfet gate pulldown.
-// 10. gas_pwm_pin: should have a series ~680-ohm R going to the servo.
-
-// Note onewire works on pins 19-21 but not on pins 39-42
-// If one more pin becomes needed, encoder_sw may be moved to pin 0, freeing up pin 38 (pin 0 requires a pullup, which encoder_sw has)
-// ESP32-S3 TRM: https://www.espressif.com/sites/default/files/documentation/esp32-s3_technical_reference_manual_en.pdf#dma
-// ESP32-S3 Datasheet: https://www.espressif.com/sites/default/files/documentation/esp32-s3_datasheet_en.pdf
-// ESP32-S3 has 5 DMA channels in each direction. We would use them for SPI data out to TFT, Neopixel data out, and possibly out to the 3 motor outputs and in from the 4 hotrc channels.
-// DMA works with: RMT, I2S0, I2S1, SPI2, SPI3, ADC, internal RAM, external PSRAM, and a few others (see the TRM)
-// Official pin capabilities: https://docs.espressif.com/projects/esp-idf/en/latest/esp32s3/hw-reference/esp32s3/user-guide-devkitc-1.html?highlight=devkitc#user-guide-s3-devkitc-1-v1-1-header-blocks
-// ADC ch2 will not work if wifi is enabled
-// Bootstrap pins: Pin 0 must be pulled high, and pins 45 and 46 pulled low during bootup
-// ESP32 errata 3.11: Pin 36 and 39 will be pulled low for ~80ns when "certain RTC peripherals power up"
-// SPI bus page including DMA information: https://docs.espressif.com/projects/esp-idf/en/v4.4/esp32s3/api-reference/peripherals/spi_master.html
-// BM2023 pins: onewire 19, hotrc_ch3_pin 20, hotrc_ch4_pin 21, tach_pin 36, ignition_pin 37, encoder_b_pin 40, encoder_a_pin 41, encoder_sw_pin 42
-
-#define tft_ledk_pin -1   // Output, optional PWM signal to control brightness of LCD backlight (needs modification to shield board to work)
-#define touch_irq_pin 255 // Input, optional touch occurence interrupt signal (for resistive touchscreen, prevents spi bus delays) - Set to 255 if not used
-#define tft_rst_pin -1    // TFT Reset allows us to reboot the screen hardware when it crashes. Otherwise connect screen reset line to esp reset pin
-
-#define adcbits 12
-#define adcrange_adc 4095     // = 2^adcbits-1
-#define adcmidscale_adc 2047  // = 2^(adcbits-1)-1
-
-// fast macros
-#define arraysize(x) ((int32_t)(sizeof(x) / sizeof((x)[0])))  // A macro function to determine the length of string arrays
-#define floor(amt, lim) ((amt <= lim) ? lim : amt)
-#define ceiling(amt, lim) ((amt >= lim) ? lim : amt)
-#undef min
-#undef max
-// these global enums are reeeeally convenient and make code very readable, but error-prone.
-// we need to be careful when changing anything - best to keep all of this here in one place!
-enum hotrc_axis : int { horz=0, vert=1, ch3=2, ch4=3 };
-enum hotrc_val : int { opmin=0, cent=1, opmax=2, raw=3, filt=4, dbbot=5, dbtop=6, margin=7 };
-enum motor_val : int { parked=1, out=3, govern=4 , absmin=5, absmax=6};
-enum stop_val : int { stop=1 };
-enum steer_val : int { safe=1 };
-enum size_enums : int { num_axes=2, num_chans=4, num_motorvals=7, num_valus=8 };
-enum joydirs : int { joy_rt=-2, joy_down=-1, joy_cent=0, joy_up=1, joy_lt=2 };
-enum runmode : int { BASIC, ASLEEP, SHUTDOWN, STALL, HOLD, FLY, CRUISE, CAL, num_runmodes };
-enum req : int { req_na=-1, req_off=0, req_on=1, req_tog=2 };  // requesting handler actions of digital values with handler functions
-enum cruise_modes { pid_suspend_fly, throttle_angle, throttle_delta };
-enum sw_presses { NONE, SHORT, LONG }; // used by encoder sw and button algorithms
-
-// global configuration settings
-bool starter_signal_support = true;
-bool remote_start_support = true;
-bool autostop_disabled = false;       // Temporary measure to keep brake behaving until we get it debugged. Eventually should be false
-bool allow_rolling_start = false;    // May be a smart prerequisite, may be us putting obstacles in our way
-bool flip_the_screen = true;
-bool cruise_speed_lowerable = true;  // Allows use of trigger to adjust cruise speed target without leaving cruise mode.  Otherwise cruise button is a "lock" button, and trigger activity cancels lock
-// Dev-board-only options:  Note these are ignored and set false at boot by set_board_defaults() unless running on a breadboard with a 22k-ohm pullup to 3.3V the TX pin
-bool usb_jtag = true;  // If you will need the usb otg port for jtag debugging (see https://docs.espressif.com/projects/esp-idf/en/latest/esp32s3/api-guides/jtag-debugging/configure-builtin-jtag.html)
-bool dont_take_temperatures = false;  // In case debugging dallas sensors or causing problems
-bool console_enabled = true;         // safer to disable because serial printing itself can easily cause new problems, and libraries might do it whenever
-bool keep_system_powered = false;    // Use true during development
-bool screensaver = false;  // Can enable experiment with animated screen draws
-bool looptime_print = false;         // Makes code write out timestamps throughout loop to serial port
-bool touch_reticles = false;
-
-// global state variables.  maybe should belong to runmodemanager class
-bool shutdown_incomplete = true;     // minor state variable for shutdown mode - Shutdown mode has not completed its work and can't yet stop activity
-bool we_just_switched_modes = true;  // For mode logic to set things up upon first entry into mode
-bool park_the_motors = false;        // Indicates we should release the brake & gas so the pedals can be used manually without interference
-bool autostopping = false, autostopping_last = false;           // true when in process of stopping the car (hold or shutdown modes)
-bool car_hasnt_moved = false;        // minor state variable for fly mode - Whether car has moved at all since entering fly mode
-bool joy_centered = false;  // minor state variable for hold mode
-bool powering_up = false;  // minor state variable for asleep mode
-float flycruise_vert_margin_pc = 0.3; // Margin of error for determining hard brake value for dropping out of cruise mode
-bool cal_joyvert_brkmotor_mode = false; // Allows direct control of brake motor using controller vert
-bool cal_pot_gasservo_mode = false;     // Allows direct control of gas servo using pot. First requires pot to be in valid position before mode is entered
-bool cal_pot_gasservo_ready = false;    // Whether pot is in valid range
-bool running_on_devboard = false;    // will overwrite with value read thru pull resistor on tx pin at boot
-bool flashdemo = false;
-int sleep_request = req_na;
-bool calmode_request = false;
-bool flycruise_toggle_request = false;
-int32_t idelta = 0, idelta_touch = 0, idelta_encoder = 0;
-
-// Cruise : is active on demand while driving.
-// Pick from 3 different styles of adjusting cruise setpoint. I prefer throttle_delta.
-// pid_suspend_fly : (PID) Moving trigger from center disables pid and lets you adjust the rpm target directly like Fly mode does. Whatever speed you're at when trigger releases is new pid target  
-// throttle_angle : Cruise locks throttle angle, instead of pid. Moving trigger from center adjusts setpoint proportional to how far you push it before releasing (and reduced by an attenuation factor)
-// throttle_delta : Cruise locks throttle angle, instead of pid. Any non-center trigger position continuously adjusts setpoint proportional to how far it's pulled over time (up to a specified maximum rate)
-int cruise_setpoint_mode = throttle_delta;
-bool cruise_adjusting = false;
-int32_t cruise_delta_max_pc_per_s = 16;  // (in throttle_delta mode) What's the fastest rate cruise adjustment can change pulse width (in us per second)
-// float cruise_angle_attenuator = 0.25;  // (in throttle_angle mode) Limits the change of each adjust trigger pull to this fraction of what's possible
-float cruise_angle_attenuator = 0.016;  // (in throttle_angle mode) Limits the change of each adjust trigger pull to this fraction of what's possible
-
-bool starter = LOW;  // Set by handler only. Reflects current state of starter signal (does not indicate source)
-bool starter_drive = false;  // Set by handler only. High when we're driving starter, otherwise starter is an input
-req starter_request = req_na;
-bool syspower = HIGH;  // Set by handler only. Reflects current state of the signal
-bool ignition = LOW;  // Set by handler only. Reflects current state of the signal
-req ignition_request = req_na;
-bool panicstop = false;
-req panicstop_request = req_on;  // On powerup we assume the code just crashed during a drive, because it could have
-bool basicmodesw = LOW;
-
-inline float smax(float a, float b) { return (a > b) ? a : b; }
-inline int32_t smax(int32_t a, int32_t b) { return (a > b) ? a : b; }
-inline uint32_t smax(uint32_t a, uint32_t b) { return (a > b) ? a : b; }
-inline uint32_t smax(uint32_t a, uint32_t b, uint32_t c) { return (a > b) ? ((c > a) ? c : a) : ((c > b) ? c : b); }
-inline float smin(float a, float b) { return (a < b) ? a : b; }
-inline int32_t smin(int32_t a, int32_t b) { return (a < b) ? a : b; }
-inline uint32_t smin(uint32_t a, uint32_t b) { return (a < b) ? a : b; }
-inline uint32_t smin(uint32_t a, uint32_t b, uint32_t c) { return (a < b) ? ((c < a) ? c : a) : ((c < b) ? c : b); }
-#undef constrain
-inline float constrain(float amt, float low, float high) { return (amt < low) ? low : ((amt > high) ? high : amt); }
-inline int32_t constrain(int32_t amt, int32_t low, int32_t high) { return (amt < low) ? low : ((amt > high) ? high : amt); }
-inline uint32_t constrain(uint32_t amt, uint32_t low, uint32_t high) { return (amt < low) ? low : ((amt > high) ? high : amt); }
-inline long constrain(long amt, long low, long high) { return (amt < low) ? low : ((amt > high) ? high : amt); }
-
-// the above should be templated, i'm sure
-// template <typename T> inline T smax(T a, T b) { return (a > b) ? a : b; }
-// template <typename T> inline T smax(T a, T b, T c) { return (a > b) ? ((c > a) ? c : a) : ((c > b) ? c : b); }
-// template <typename T> inline T smin(T a, T b) { return (a < b) ? a : b; }
-// template <typename T> inline T smin(T a, T b, T c) { return (a < b) ? ((c < a) ? c : a) : ((c < b) ? c : b); }
-// template <typename T> inline T constrain(T amt, T low, T high) { return (amt < low) ? low : ((amt > high) ? high : amt); }
-// template <typename T> inline T map(T x, T in_min, T in_max, T out_min, T out_max) {
-//     if (in_max - in_min > (T)0.001) return out_min + (x - in_min) * (out_max - out_min) / (in_max - in_min);
-//     printf ("map not dividing by zero\n");
-//     return out_max;  // Instead of dividing by zero, return the highest valid result
-// }
-
-#undef map
-inline float map(float x, float in_min, float in_max, float out_min, float out_max) {
-    if (in_max - in_min) return out_min + (x - in_min) * (out_max - out_min) / (in_max - in_min);
-    return out_max;  // Instead of dividing by zero, return the highest valid result
-}
-inline int32_t map(int32_t x, int32_t in_min, int32_t in_max, int32_t out_min, int32_t out_max) {
-    if (in_max - in_min) return out_min + (x - in_min) * (out_max - out_min) / (in_max - in_min);
-    return out_max;  // Instead of dividing by zero, return the highest valid result
-}
-bool rounding = true;
-float dround(float val, int32_t digits) { return (rounding) ? (std::round(val * std::pow (10, digits)) / std::pow (10, digits)) : val; }
-
-// pin operations
-void set_pin(int32_t pin, int32_t mode) { if (pin >= 0 && pin != 255) pinMode (pin, mode); }
-void write_pin(int32_t pin, int32_t val) {  if (pin >= 0 && pin != 255) digitalWrite (pin, val); }
-int32_t read_pin(int32_t pin) { return (pin >= 0 && pin != 255) ? digitalRead (pin) : -1; }
-
-float convert_units(float from_units, float convert_factor, bool invert, float in_offset = 0.0, float out_offset = 0.0) {
-    if (!invert) return out_offset + convert_factor * (from_units - in_offset);
-    if (from_units - in_offset) return out_offset + convert_factor / (from_units - in_offset);
-    printf ("convert_units refused to divide by zero: %lf, %lf, %d, %lf, %lf", from_units, convert_factor, invert, in_offset, out_offset);
-    return -1;
-}
-
-// Exponential Moving Average filter : Smooth out noise on inputs. 0 < alpha < 1 where lower = smoother and higher = more responsive
-// Pass in a fresh raw value, address of filtered value, and alpha factor, filtered value will get updated
-float ema_filt(float raw, float filt, float alpha) {
-    return (alpha * raw) + ((1 - alpha) * filt);
-}
-template<typename RAW_T, typename FILT_T>
-void ema_filt(RAW_T raw, FILT_T* filt, float alpha) {
-    float raw_f = static_cast<float>(raw);
-    float filt_f = static_cast<float>(*filt);
-    *filt = static_cast<FILT_T>(ema_filt(raw_f, filt_f, alpha));
-}
-
-template <typename T>
-T adj_val(T variable, T modify, T low_limit, T high_limit) {
-    T oldval = variable;
-    variable += modify;
-    return variable < low_limit ? low_limit : (variable > high_limit ? high_limit : variable);
-}
-bool adj_val(int32_t *variable, int32_t modify, int32_t low_limit, int32_t high_limit) { // sets an int reference to new val constrained to given range
-    int32_t oldval = *variable;
-    *variable = adj_val(*variable, modify, low_limit, high_limit);
-    return (*variable != oldval);
-}
-bool adj_val(float *variable, float modify, float low_limit, float high_limit) { // sets an int reference to new val constrained to given range
-    float oldval = *variable;
-    *variable = adj_val(*variable, modify, low_limit, high_limit);
-    return (*variable != oldval);
-}
-bool adj_bool(bool val, int32_t delta) { return delta != 0 ? delta > 0 : val; } // returns 1 on delta=1, 0 on delta=-1, or val on delta=0
-void adj_bool(bool *val, int32_t delta) { *val = adj_bool(*val, delta); }       // sets a bool reference to 1 on 1 delta or 0 on -1 delta
-
-class Timer {  // !!! beware, this 54-bit microsecond timer overflows after every 571 years !!!
-  protected:
-    volatile int64_t start_us, timeout_us;
-  public:
-    Timer() { reset(); }
-    Timer(int arg_timeout_us) { set ((int64_t)arg_timeout_us); }
-    void IRAM_ATTR set (int64_t arg_timeout_us) {
-        timeout_us = arg_timeout_us;
-        start_us = esp_timer_get_time();
-    }
-    void IRAM_ATTR reset() { start_us = esp_timer_get_time(); }
-    bool IRAM_ATTR expired() { return esp_timer_get_time() >= start_us + timeout_us; }
-    bool IRAM_ATTR expireset() {  // Like expired() but immediately resets if expired
-        int64_t now_us = esp_timer_get_time();
-        if (now_us < start_us + timeout_us) return false;
-        start_us = now_us;
-        return true;
-    }    
-    int64_t IRAM_ATTR elapsed() { return esp_timer_get_time() - start_us; }
-    int64_t IRAM_ATTR timeout() { return timeout_us; }
-};
-class I2C {
-    private:
-        int32_t _devicecount = 0;
-        uint8_t _addrs[10];
-        uint8_t _sda_pin, _scl_pin;
-        Timer scanTimer;
-    public:
-        I2C(uint8_t sda_pin_arg, uint8_t scl_pin_arg) : _sda_pin(sda_pin_arg), _scl_pin(scl_pin_arg) {}
-
-        void init() {
-            printf("I2C driver ");
-            scanTimer.reset();
-            Wire.begin(_sda_pin, _scl_pin);  // I2c bus needed for airflow sensor
-            byte error, address;
-            printf(" scanning ...");
-            _devicecount = 0;
-            for (address = 1; address < 127; address++ ) {
-                Wire.beginTransmission(address);
-                error = Wire.endTransmission();
-                if (error == 0) {
-                    printf (" found addr: 0x%s%x", (address < 16) ? "0" : "", address);
-                    _addrs[_devicecount++] = address;
-                }
-                else if (error==4) printf (" error addr: 0x%s%x", (address < 16) ? "0" : "", address);
-            }
-            if (scanTimer.elapsed() > 5000000) printf(" timeout & fail bus scan.");
-            if (_devicecount == 0) printf(" no devices found.");
-            printf(" done\n");
-        }
-
-        bool device_detected(uint8_t addr) {
-            for (int32_t i=0; i < _devicecount; i++) {
-                if (_addrs[i] == addr) return true;
-            }
-            return false;
-        }
-};
\ No newline at end of file
diff --git a/CANTroller2/src/display.h b/CANTroller2/src/display.h
index 2ace5ce..6629bab 100755
--- a/CANTroller2/src/display.h
+++ b/CANTroller2/src/display.h
@@ -185,7 +185,7 @@ uint8_t unitmaps[8][17] = {  // 17x7-pixel bitmaps for where units use symbols n
 bool* idiotlights[16] = {
     &(err_sensor_alarm[LOST]), &(err_sensor_alarm[RANGE]), &(temp_err[ENGINE]), &(temp_err[WHEEL]), &panicstop, 
     hotrc.radiolost_ptr(), &shutdown_incomplete, &park_the_motors, &autostopping, &cruise_adjusting,
-    &car_hasnt_moved, &starter, &boot_button, sim.enabled_ptr(), &running_on_devboard, 
+    &car_hasnt_moved, &starter, &(encoder.sw), sim.enabled_ptr(), &running_on_devboard, 
     &powering_up,
 };
 char idiotchars[arraysize(idiotlights)][3] = {
@@ -232,9 +232,9 @@ void set_idiotcolors() {
 // tuning-ui related globals
 enum disp_draw { ERASE = -1 };
 enum tunctrls { OFF, SELECT, EDIT };
-int32_t tunctrl = OFF, tunctrl_last = OFF;
-int32_t datapage = PG_RUN, datapage_last = PG_TEMP;  // Which of the six 8-value dataset pages is currently displayed, and available to edit
-int32_t sel_val = 0, sel_val_last = 0;  // In the real time tuning UI, which of the editable values (0-7) is selected. -1 for none 
+int tunctrl = OFF, tunctrl_last = OFF;
+int datapage = PG_RUN, datapage_last = PG_TEMP;  // Which of the six 8-value dataset pages is currently displayed, and available to edit
+int sel_val = 0, sel_val_last = 0;  // In the real time tuning UI, which of the editable values (0-7) is selected. -1 for none 
 Timer tuningCtrlTimer (25000000);  // This times out edit mode after a a long period of inactivity
 
 class Display {
@@ -434,7 +434,7 @@ class Display {
                 if (color == -1) color = GRN;
                 int32_t y_pos = lineno*disp_line_height_pix+disp_vshift_pix;
                 if (polarity != disp_polarities[lineno]) draw_hyphen (x_base, y_pos, (!polarity) ? color : BLK);
-                draw_string (x_base+disp_font_width, x_base+disp_font_width, y_pos, disp_string, disp_values[lineno], color, BLK); // +6*(arraysize(modecard[run.mode()])+4-namelen)/2
+                draw_string (x_base+disp_font_width, x_base+disp_font_width, y_pos, disp_string, disp_values[lineno], color, BLK); // +6*(arraysize(modecard[run.mode])+4-namelen)/2
                 strcpy (disp_values[lineno], disp_string);
                 disp_polarities[lineno] = polarity;
                 dispAgeTimer[lineno].reset();
@@ -666,7 +666,7 @@ class Display {
         void update_idiots(bool force = false) {
             draw_idiotlights(disp_idiot_corner_x, disp_idiot_corner_y, force);
         }
-        void update(runmode _nowmode) {
+        void update(int _nowmode) {
             if (!display_enabled) return;
             update_idiots(disp_idiots_dirty);
             disp_idiots_dirty = false;
@@ -788,7 +788,7 @@ class Display {
                     draw_dynamic(13, gas.pid.dterm(), -100.0, 100.0);
                     draw_dynamic(14, gas.pid.outsum(), -gas.pid.outrange(), gas.pid.outrange());
                     draw_eraseval(15);
-                    draw_truth(16, gas.open_loop, 1);
+                    draw_truth(16, gas.openloop, 1);
                     draw_dynamic(17, gas.pid.kp(), 0.0, 1.0);
                     draw_dynamic(18, gas.pid.ki(), 0.0, 1.0);
                     draw_dynamic(19, gas.pid.kd(), 0.0, 1.0);
@@ -942,6 +942,7 @@ class Display {
 // moving transparent arrow sprite over background: https://www.youtube.com/watch?v=U4jOFLFNZBI&ab_channel=VolosProjects
 // bar graphs: https://www.youtube.com/watch?v=g4jlj_T-nRw&ab_channel=VolosProjects
 
+int32_t idelta = 0, idelta_touch = 0, idelta_encoder = 0;
 void tuner_update(int rmode) {
     sel_val_last = sel_val;
     datapage_last = datapage;
@@ -1013,7 +1014,7 @@ void tuner_update(int rmode) {
             else if (sel_val == 10) brake.pid.add_kd(0.001 * fdelta);
         }
         else if (datapage == PG_GPID) {
-            if (sel_val == 7) { adj_bool(&(gas.open_loop), idelta); }  // gas_pid.SetMode (gas_open_loop ? qpid::ctrl::manual : qpid::ctrl::automatic);
+            if (sel_val == 7) { adj_bool(&(gas.openloop), idelta); }  // gas_pid.SetMode (gas_open_loop ? QPID::ctrl::manual : QPID::ctrl::automatic);
             else if (sel_val == 8) gas.pid.add_kp(0.001 * fdelta);
             else if (sel_val == 9) gas.pid.add_ki(0.001 * fdelta);
             else if (sel_val == 10) gas.pid.add_kd(0.001 * fdelta);
@@ -1037,8 +1038,8 @@ void tuner_update(int rmode) {
             else if (sel_val == 6) sim.set_can_sim(sens::mapsens, idelta);  // else if (sel_val == 7) sim.set_can_sim(sens::starter, idelta);
             else if (sel_val == 7) sim.set_can_sim(sens::basicsw, idelta);
             else if (sel_val == 8) sim.set_potmap((adj_val(sim.potmap(), idelta, 0, arraysize(sensorcard) - 4)));            
-            else if (sel_val == 9 && rmode == CAL) adj_bool(&cal_joyvert_brkmotor_mode, idelta);
-            else if (sel_val == 10 && rmode == CAL) adj_bool(&cal_pot_gasservo_mode, (idelta < 0 || cal_pot_gasservo_ready) ? idelta : -1);
+            else if (sel_val == 9 && rmode == CAL) adj_bool(&(cal_joyvert_brkmotor_mode), idelta);
+            else if (sel_val == 10 && rmode == CAL) adj_bool(&(cal_pot_gasservo_mode), (idelta < 0 || cal_pot_gasservo_ready) ? idelta : -1);
         }
         else if (datapage == PG_UI) {
             if (sel_val == 7) { adj_bool(&flashdemo, idelta); enable_flashdemo(flashdemo); }
diff --git a/CANTroller2/src/globals.h b/CANTroller2/src/globals.h
old mode 100755
new mode 100644
index 7bcf90c..e12706f
--- a/CANTroller2/src/globals.h
+++ b/CANTroller2/src/globals.h
@@ -1,429 +1,295 @@
-#pragma once
-#include <Preferences.h>  // Functions for writing to flash, i think
-#include <iomanip>  // For formatting console loop timing string output
-#include <vector>  // used to group loop times with string labels
-// #include <HardwareSerial.h>  // In case we ever talk to jaguars over asynchronous serial port, uncomment:
-// HardwareSerial jagPort(1); // Open serisl port to communicate with jaguar controllers for steering & brake motors
-
-enum temp_categories { AMBIENT = 0, ENGINE = 1, WHEEL = 2, num_temp_categories };
-enum temp_lims { DISP_MIN, OP_MIN, OP_MAX, WARNING, ALARM, DISP_MAX }; // Possible sources of gas, brake, steering commands
-float temp_lims_f[3][6]{
-    {0.0, 45.0, 115.0, 120.0, 130.0, 220.0},  // [AMBIENT][DISP_MIN/OP_MIN/OP_MAX/WARNING/ALARM]
-    {0.0, 178.0, 198.0, 202.0, 205.0, 220.0}, // [ENGINE][DISP_MIN/OP_MIN/OP_MAX/WARNING/ALARM]
-    {0.0, 50.0, 120.0, 130.0, 140.0, 220.0},  // [WHEEL][DISP_MIN/OP_MIN/OP_MAX/WARNING/ALARM] (applies to all wheels)
-};
-float temp_room = 77.0;          // "Room" temperature is 25 C = 77 F  Who cares?
-float temp_sensor_min_f = -67.0; // Minimum reading of sensor is -25 C = -67 F
-float temp_sensor_max_f = 257.0; // Maximum reading of sensor is 125 C = 257 F
-bool temp_err[num_temp_categories];  // [AMBIENT/ENGINE/WHEEL]
-
-// Instantiate objects
-static Preferences config;  // Persistent config storage
-static Hotrc hotrc;
-static Potentiometer pot(pot_wipe_pin);
-static Simulator sim(pot);
-static TemperatureSensorManager tempsens(onewire_pin);
-static Encoder encoder(encoder_a_pin, encoder_b_pin, button_pin);
-static CarBattery mulebatt(mulebatt_pin);
-static LiPoBatt lipobatt(lipobatt_pin);
-static PressureSensor pressure(pressure_pin);
-static BrakePositionSensor brakepos(brake_pos_pin);
-static Speedometer speedo(speedo_pin);
-static Tachometer tach(tach_pin);
-static I2C i2c(i2c_sda_pin, i2c_scl_pin);
-static AirVeloSensor airvelo(i2c);
-static MAPSensor mapsens(i2c);
-static Throttle throttle;
-static GasServo gas;
-static BrakeMotor brake;
-static SteerMotor steer;
-static neopixelstrip neo;
-
-// RTOS task that updates temp sensors in a separate task
-void update_temperature_sensors(void *parameter) {
-    while (true) {
-        if (!dont_take_temperatures)
-            tempsens.update_temperatures();
-        if (sim.potmapping(sens::engtemp)) {
-            TemperatureSensor *engine_sensor = tempsens.get_sensor(loc::engine);
-            if (engine_sensor != nullptr) {
-                engine_sensor->set_temperature(pot.mapToRange(temp_sensor_min_f, temp_sensor_max_f));
-            }
-        }
-        vTaskDelay(pdMS_TO_TICKS(1000)); // Delay for a second to avoid updating the sensors too frequently
-    }
-}
-
-void set_board_defaults(bool devboard) {  // true for dev boards, false for printed board (on the car)
-    if (devboard) {
-        sim.set_can_sim(sens::pressure, true);
-        sim.set_can_sim(sens::brkpos, true);
-        sim.set_can_sim(sens::tach, true);
-        sim.set_can_sim(sens::speedo, true);
-        sim.set_can_sim(sens::mapsens, true);
-        sim.set_can_sim(sens::airvelo, true);
-        sim.set_can_sim(sens::basicsw, true);
-        sim.set_potmap(sens::pressure);
-    }
-    else {  // override settings if running on the real car
-        usb_jtag = false;
-        console_enabled = false;     // safer to disable because serial printing itself can easily cause new problems, and libraries might do it whenever
-        keep_system_powered = false; // Use true during development
-        screensaver = false;         // Can enable experiment with animated screen draws
-        looptime_print = false;      // Makes code write out timestamps throughout loop to serial port
-        dont_take_temperatures = false;
-        touch_reticles = false;
-    }
-}
-
-Timer starterTimer(5000000);  // If remotely-started starting event is left on for this long, end it automatically  
-Timer panicTimer(20000000);  // How long should a panic stop last?  We can't stay mad forever
-
-void starter_update () {  // Starter bidirectional handler logic.  Outside code interacts with handler by setting starter_request = req_off, req_on, or req_tog
-    if (starter_signal_support) {
-        if (starter_request == req_tog) starter_request = (req)(!starter_drive);  // translate toggle request to a drive request opposite to the current drive state
-        if (starter_drive && ((starter_request == req_off) || starterTimer.expired())) {  // If we're driving the motor but need to stop
-            starter_drive = false;
-            set_pin (starter_pin, INPUT_PULLDOWN);  // we never assert low on the pin, just set pin as input and let the pulldown bring it low
-        }
-        if (!starter_drive && (starter_request != req_on) && !sim.simulating(sens::starter)) {  // If we haven't been and shouldn't be driving, and not simulating
-            do {
-                starter = digitalRead(starter_pin);  // then read the pin, starter variable will store if starter is turned on externally
-            } while (starter != digitalRead(starter_pin)); // starter pin has a tiny (70ns) window in which it could get invalid low values, so read it twice to be sure
-        }
-        else if (!starter && (starter_request == req_on) && remote_start_support) {  // If we got a request to start the motor, and it's not already being driven externally
-            starter_drive = true;
-            starter = HIGH;
-            set_pin (starter_pin, OUTPUT);  // then set pin to an output
-            write_pin (starter_pin, starter);  // and start the motor
-            starterTimer.reset();  // if left on the starter will turn off automatically after X seconds
-        }
-        starter_request = req_na;  // we have serviced whatever requests
-    }
-    else starter = LOW;
-}
-void ignition_panic_update() {  // Run once each main loop, directly before panicstop_update()
-    if (panicstop_request == req_tog) panicstop_request = (req)(!panicstop);
-    if (ignition_request == req_tog) ignition_request = (req)(!ignition);
-    // else if (ignition_request == ignition) ignition_request = req_na;  // With this line, it ignores requests to go to state it's already in, i.e. won't do unnecessary pin write
-    if (speedo.car_stopped() || panicTimer.expired()) panicstop_request = req_off;  // Cancel panic stop if car is stopped
-    if (!speedo.car_stopped()) {
-        if (ignition && ignition_request == req_off) panicstop_request = req_on;  // ignition cut causes panic stop
-        if (!sim.simulating(sens::joy) && hotrc.radiolost()) panicstop_request = req_on;
-    }
-    bool paniclast = panicstop;
-    if (panicstop_request != req_na) {
-        panicstop = (bool)panicstop_request;
-        if (panicstop && !paniclast) panicTimer.reset();
-    }
-    panicstop_request = req_na;
-    if (panicstop) ignition_request = req_off;  // panic stop causes ignition cut
-    if (ignition_request != req_na) {
-        ignition = (bool)ignition_request;
-        write_pin (ignition_pin, ignition);  // Turn car off or on (ign output is active high), ensuring to never turn on the ignition while panicking
-    }
-    ignition_request = req_na;  // Make sure this goes after the last comparison
-}
-void basicsw_update() {
-    if (!sim.simulating(sens::basicsw)) {  // Basic Mode switch
-        do {
-            basicmodesw = !digitalRead(basicmodesw_pin);   // !value because electrical signal is active low
-        } while (basicmodesw != !digitalRead(basicmodesw_pin)); // basicmodesw pin has a tiny (70ns) window in which it could get invalid low values, so read it twice to be sure
-    }
-}
-void set_syspower(bool setting) {
-    syspower = setting;
-    if (keep_system_powered) syspower = HIGH;
-    write_pin(syspower_pin, syspower);
-}
-bool boot_button_last = 0;
-bool boot_button = 0;
-bool boot_button_timer_active = false;
-bool boot_button_suppress_click = false;
-bool boot_button_action = NONE;
-Timer boot_button_timer(400000);
-//
-void bootbutton_update() {
-    // ESP32 "boot" button. generates boot_button_action flags of LONG or SHORT presses which can be handled wherever. Handler must reset boot_button_action = NONE
-    if (button_pin < 0) return;
-    // if (boot_button_action == SHORT) {
-    //     syspower_request = req_on;
-    //     boot_button_action == NONE;
-    // }
-    if (!read_pin (button_pin)) {
-        if (!boot_button) {  // If press just occurred
-            boot_button_timer.reset();  // Looks like someone just pushed the esp32 "boot" button
-            boot_button_timer_active = true;  // flag to indicate timing for a possible long press
-        }
-        else if (boot_button_timer_active && boot_button_timer.expired()) {
-            boot_button_action = LONG;  // Set flag to handle the long press event. Note, routine handling press should clear this
-            boot_button_timer_active = false;  // Clear timer active flag
-            boot_button_suppress_click = true;  // Prevents the switch release after a long press from causing a short press
-        }
-        boot_button = true;  // Store press is in effect
-    }
-    else {  // if button is not being pressed
-        if (boot_button && !boot_button_suppress_click) boot_button_action = SHORT;  // if the button was just released, a short press occurred, which must be handled
-        // else boot_button_action = NONE;  // This would auto-reset the button action flag but require it get handled in this loop. Otherwise the handler must set this
-        boot_button_timer_active = false;  // Clear timer active flag
-        boot_button = false;  // Store press is not in effect
-        boot_button_suppress_click = false;  // End click suppression
-    }
-}
-// Loop timing related
-uint32_t looptime_linefeed_threshold = 0;  // Leaves prints of loops taking > this for analysis. Set to 0 prints every loop
-Timer loopTimer(1000000); // how long the previous main loop took to run (in us)
-float loop_sum_s, loop_avg_us, loopfreq_hz;
-uint32_t looptimes_us[20];
-bool loop_dirty[20];
-int32_t loopno = 1, loopindex = 0, loop_recentsum = 0, loop_scale_min_us = 0, loop_scale_avg_max_us = 2500, loop_scale_peak_max_us = 25000;
-int64_t loop_cout_mark_us;
-uint32_t loop_cout_us = 0, loop_peak_us = 0, loop_now = 0;;
-const uint32_t loop_history = 100;
-uint32_t loop_periods_us[loop_history];
-std::vector<std::string> loop_names(20);
-//
-void looptime_init() {  // Run once at end of setup()
-    if (looptime_print) {
-        for (int32_t x=1; x<arraysize(loop_dirty); x++) loop_dirty[x] = true;
-        loop_names[0] = std::string("top");
-        loop_dirty[0] = false;
-        loopindex = 1;
-        looptimes_us[0] = esp_timer_get_time();
-    }
-    loopTimer.reset();  // start timer to measure the first loop
-}
-void looptime_mark(std::string loopname = std::string("")) {  // Add marks wherever you want in the main loop, set looptime_print true, will report times between all adjacent marks
-    if (looptime_print) {
-        if (loop_dirty[loopindex]) {
-            loop_names[loopindex] = loopname;  // names[index], name);
-            loop_dirty[loopindex] = false;
-        }
-        looptimes_us[loopindex] = esp_timer_get_time();
-        loopindex++;
-    }
-}
-float loop_calc_avg(uint32_t _loop_now, uint32_t _thisloop) {
-    if (_loop_now == loop_history + 2) {
-        loop_recentsum = _thisloop;
-        for (int l = 0; l <= loop_history; l++)
-            loop_recentsum += loop_periods_us[(_loop_now + l) % loop_history];
-    }
-    else loop_recentsum += _thisloop - loop_periods_us[loop_now];
-    return (float)loop_recentsum/(float)loop_history;
-}
-void looptime_update() {  // Call once each loop at the very end
-    uint32_t thisloop = (uint32_t)loopTimer.elapsed();
-    loop_avg_us = loop_calc_avg(loop_now, thisloop);
-    loop_periods_us[loop_now] = thisloop;  // us since beginning of this loop
-    loopTimer.reset();
-    loop_sum_s += (float)loop_periods_us[loop_now] / 1000000;
-    // ema_filt(loop_periods_us[loop_now], &loop_avg_us, 0.01);
-    if (loop_avg_us > 1) loopfreq_hz = 1000000/loop_avg_us;
-    loop_peak_us = 0;
-    for (int8_t i=0; i<loop_history; i++) if (loop_peak_us < loop_periods_us[i]) loop_peak_us = loop_periods_us[i]; 
-    if (looptime_print) {
-        loop_cout_mark_us = esp_timer_get_time();
-        std::cout << std::fixed << std::setprecision(0);
-        std::cout << "\r" << (uint32_t)loop_sum_s << "s #" << loopno;  //  << " av:" << std::setw(5) << (int32_t)(loop_avg_us);  //  << " av:" << std::setw(3) << loop_avg_ms 
-        std::cout << " : " << std::setw(5) << loop_periods_us[loop_now] << " (" << loop_periods_us[loop_now]-loop_cout_us << ")us ";  // << " avg:" << loop_avg_us;  //  " us:" << esp_timer_get_time() << 
-        for (int32_t x=1; x<loopindex; x++)
-            std::cout << std::setw(3) << loop_names[x] << ":" << std::setw(5) << looptimes_us[x]-looptimes_us[x-1] << " ";
-        std::cout << " cout:" << std::setw(5) << loop_cout_us;
-        if (loop_periods_us[loop_now]-loop_cout_us > looptime_linefeed_threshold || !looptime_linefeed_threshold) std::cout << std::endl;
-        loop_cout_us = (uint32_t)(esp_timer_get_time() - loop_cout_mark_us);
-        loopindex = 0;
-        looptime_mark ("top");
-    }
-    ++loop_now %= loop_history;
-    loopno++;  // I like to count how many loops
-}
-// Diag / trouble codes
-uint32_t err_timeout_us = 175000;
-Timer errTimer((int64_t)err_timeout_us);
-uint32_t err_margin_adc = 5;
-// Sensor related trouble - this all should be moved to devices.h
-enum err_type { LOST, RANGE, CALIB, WARN, CRIT, INFO, num_err_types };
-enum err_sens { e_hrcvert, e_hrcch3, e_pressure, e_brkpos, e_speedo, e_hrchorz, e_tach, e_temps, e_starter, e_hrcch4, e_basicsw, e_mulebatt, e_lipobatt, e_airvelo, e_mapsens, e_num_sensors, e_none };  // these are in order of priority
-char err_type_card[num_err_types][5] = { "Lost", "Rang", "Cal", "Warn", "Crit", "Info" };
-char err_sensor_card[e_num_sensors+1][7] = { "HrcV", "HrcCh3", "BrPres", "BrkPos", "Speedo", "HrcH", "Tach", "Temps", "Startr", "HrcCh4", "Basic", "MulBat", "LiPo", "Airflw", "MAP", "None" };
-// enum class sensor : opt_t { none=0, joy, pressure, brkpos, speedo, tach, airvelo, mapsens, engtemp, mulebatt, ignition, basicsw, cruisesw, starter, syspower };  // , num_sensors, err_flag };
-bool err_sensor_alarm[num_err_types] = { false, false, false, false, false, false };
-int8_t err_sensor_fails[num_err_types] = { 0, 0, 0, 0, 0, 0 };
-bool err_sensor[num_err_types][e_num_sensors]; //  [LOST/RANGE] [e_hrchorz/e_hrcvert/e_hrcch3/e_hrcch4/e_pressure/e_brkpos/e_tach/e_speedo/e_airvelo/e_mapsens/e_temps/e_mulebatt/e_lipobatt/e_basicsw/e_starter]   // sens::opt_t::num_sensors]
-uint8_t highest_pri_failing_sensor[num_err_types];
-uint8_t highest_pri_failing_last[num_err_types];
-bool diag_ign_error_enabled = true;
-
-void diag_update() {
-    if (errTimer.expireset()) {
-
-        // Auto-Diagnostic  :   Check for worrisome oddities and dubious circumstances. Report any suspicious findings
-        // this is one approach
-        // This section should become a real time self-diagnostic system, to look for anything that doesn't seem right and display an
-        // informed trouble code. Much like the engine computer in cars nowadays, which keep track of any detectable failures for you to
-        // retreive with an OBD tool. Some checks are below, along with other possible things to check for:
-        if (!ignition && !tach.engine_stopped()) {  // Check: if engine is turning when ignition signal is off
-            if (diag_ign_error_enabled) { // See if the engine is turning despite the ignition being off
-                Serial.println (F("Detected engine rotation in the absense of ignition signal"));  // , tach_filt_rpm, ignition
-                diag_ign_error_enabled = false;  // Prevents endless error reporting the same error
-            }
-        }
-        else diag_ign_error_enabled = true;
-
-        // different approach
-        bool not_detected;
-        not_detected = false;  // first reset
-        for (int cat = 0; cat < num_temp_categories; cat++) temp_err[cat] = false;  // first reset
-        for (int loc = 0; loc < tempsens.locint(loc::num_locations); loc++) {
-            if (!tempsens.detected(loc)) not_detected = true;
-            else if (tempsens.val(loc) >= temp_lims_f[tempsens.errclass(loc)][WARNING]) temp_err[tempsens.errclass(loc)] = true;
-        }
-        err_sensor[LOST][e_temps] = not_detected;
-
-        // Detect sensors disconnected or giving out-of-range readings.
-        // TODO : The logic of this for each sensor should be moved to devices.h objects
-        err_sensor[RANGE][e_brkpos] = (brakepos.in() < brakepos.op_min_in() || brakepos.in() > brakepos.op_max_in());
-        err_sensor[LOST][e_brkpos] = (brakepos.raw() < err_margin_adc);
-        err_sensor[RANGE][e_pressure] = (pressure.psi() < pressure.op_min_psi() || pressure.psi() > pressure.op_max_psi());
-        err_sensor[LOST][e_pressure] = (pressure.raw() < err_margin_adc);
-        err_sensor[RANGE][e_mulebatt] = (mulebatt.v() < mulebatt.op_min_v() || mulebatt.v() > mulebatt.op_max_v());
-        for (int32_t ch = horz; ch <= ch4; ch++) {  // Hack: This loop depends on the indices for hotrc channel enums matching indices of hotrc sensor errors
-            err_sensor[RANGE][ch] = !hotrc.radiolost() && ((hotrc.us[ch][raw] < hotrc.us[ch][opmin] - (hotrc.us[ch][margin] >> 1)) 
-                                    || (hotrc.us[ch][raw] > hotrc.us[ch][opmax] + (hotrc.us[ch][margin] >> 1)));  // && ch != vert
-            err_sensor[LOST][ch] = !hotrc.radiolost() && ((hotrc.us[ch][raw] < (hotrc.absmin_us - hotrc.us[ch][margin]))
-                                    || (hotrc.us[ch][raw] > (hotrc.absmax_us + hotrc.us[ch][margin])));
-        }
-        // err_sensor[RANGE][e_hrcvert] = (hotrc.us[vert][raw] < hotrc.failsafe_us - hotrc.us[ch][margin])
-        //     || ((hotrc.us[vert][raw] < hotrc.us[vert][opmin] - halfmargin) && (hotrc.us[vert][raw] > hotrc.failsafe_us + hotrc.us[ch][margin]));
-        
-        // Set sensor error idiot light flags
-        // printf ("Sensors errors: ");
-        
-        // printf ("Sensor check: ");
-        for (int32_t t=LOST; t<=RANGE; t++) {
-            highest_pri_failing_sensor[t] = e_none;
-            err_sensor_alarm[t] = false;
-            err_sensor_fails[t] = 0;
-            for (int32_t s=0; s<e_num_sensors; s++)
-                if (err_sensor[t][s]) {
-                    if (highest_pri_failing_sensor[t] = e_none) highest_pri_failing_sensor[t] = s;
-                    err_sensor_alarm[t] = true;
-                    err_sensor_fails[t]++;
-                }
-        }
-        // printf ("\n");
-
-        // Detectable transducer-related failures :: How we can detect them
-        // Brakes:
-        // * Pressure sensor, chain linkage, or vehicle brakes problem :: Motor retracted with position below zeropoint, but pressure did not increase.
-        // * Pressure sensor zero point miscalibration (no force on pedal) :: Minimum pressure reading since startup has never reached 0 PSI or less (cal is too high), or, is more than a given margin below 0. * Note this can also be an auto-calibration approach
-        // * Pressure sensor max point miscalibration (full force on pedal) :: When target set to max pressure, after motor moves to the point position isn't changing, the pressure reading deviates from max setting by more than a given margin. * Note this can also be an auto-calibration approach
-        // * Position sensor problem :: When pressure is not near max, motor is driven more than X volt-seconds without position change (of the expected polarity).
-        // * Brake motor problem :: When motor is driven more than X volt-seconds without any change (of the expected polarity) to either position or pressure.
-        // * Brake calibration, idle high, or speedo sensor problem :: Motor retracted to near limit, with position decreased and pressure increased as expected, but speed doesn't settle toward 0.
-        // * Pressure sensor problem :: If pressure reading is out of range, or ever changes in the unexpected direction during motor movement.
-        // * Position sensor or limit switch problem :: If position reading is outside the range of the motor limit switches.
-        // Steering:
-        // * Chain derailment or motor or limit switch problem :: Motor told to drive for beyond X volt-seconds in one direction for > Y seconds.
-        // Throttle/Engine:
-        // * AirVelo/MAP/tach sensor failure :: If any of these three sensor readings are out of range to the other two.
-        // Tach/Speedo:
-        // * Sensor read problem :: Derivative of consecutive readings (rate of change) spikes higher than it's possible for the physical rotation to change - (indicates missing pulses)
-        // * Disconnected/problematic speed sensor :: ignition is on, tach is nonzero, and runmode = hold/fly/cruise, yet speed is zero. Or, throttle is at idle and brake pressure high for enough time, yet speed readings are nonzero
-        // * Disconnected/problematic tach sensor :: runmode is hold/fly/cruise, ignition is on and speed increases, but tach is below idle speed 
-        // Temperature:
-        // * Engine temperature sensor problem :: Over X min elapsed with Ignition on and tach >= low_idle, but engine temp is below nominal warmup temp.
-        // * Cooling system, coolant, fan, thermostat, or coolant sensor problem :: Engine temp stays over ~204 for >= X min without coolant temp dropping due to fan.
-        // * Axle, brake, etc. wheel issue or wheel sensor problem :: The hottest wheel temp is >= X degF hotter than the 2nd hottest wheel.
-        // * Axle, brake, etc. wheel issue or wheel/ambient sensor problem :: A wheel temp >= X degF higher than ambient temp.
-        // * Ignition problem, fire alarm, or temp sensor problem :: Ignition is off but a non-ambient temp reading increases to above ambient temp.
-        // AirVelo:
-        // * Air filter clogged, or carburetor problem :: Track ratio of massairflow/throttle angle whenever throttle is constant. Then, if that ratio lowers over time by X below that level, indicates restricted air. 
-        // Battery:
-        // * Battery low :: Mulebatt readings average is below a given threshold
-        // * Inadequate charging :: Mulebatt readings average has decreased over long time period
-        // 
-        // More ideas to define better and implement:
-        // * Check if the pressure response is characteristic of air being in the brake line.
-        // * Axle/brake drum may be going bad (increased engine RPM needed to achieve certain speedo)  (beware going up hill may look the same).
-        // * E-brake has been left on (much the same symptoms as above? (beware going up hill may look the same) 
-        // * Carburetor not behaving (or air filter is clogged). (See above about engine deiseling - we can detect this!)
-        // * After increasing braking, the actuator position changes in the opposite direction, or vise versa.
-        // * Changing an actuator is not having the expected effect.
-        // * A tunable value suspected to be out of tune.
-        // * Check regularly for ridiculous shit. Compare our variable values against a predetermined list of conditions which shouldn't be possible or are at least very suspect. For example:
-        //   A) Sensor reading is out of range, or has changed faster than it ever should.
-        //   B) Stopping the car on entering hold/shutdown mode is taking longer than it ever should.
-        //   C) Mule seems to be accelerating like a Tesla.
-        //   D) Car is accelerating yet engine is at idle.
-        // * The control system has nonsensical values in its variables.
-    }
-}
-void err_print_info() {
-    for (int32_t t=LOST; t<=INFO; t++) {
-        printf ("diag err: %s (%d): ", err_type_card[t], err_sensor_fails[t]);
-        for (int32_t s=0; s<=e_num_sensors; s++) {
-            if (s == e_num_sensors) s++;
-            if (err_sensor[t][s]) printf ("%s, ", err_sensor_card[s]);
-        }
-        printf("\n");
-    }
-}
-int16_t touch_pt[4] = { 160, 120, 2230, 2130 };
-
-// Neopixel stuff
-int32_t neobright = 10;  // lets us dim/brighten the neopixels
-int32_t neodesat = 0;  // lets us de/saturate the neopixels
-
-void neo_setup() {
-    neo.init((uint8_t)neopixel_pin, running_on_devboard, 1);
-    // neo.init((uint8_t)neopixel_pin, !running_on_devboard);
-    neo.setbright(neobright);
-    neo.setdesaturation(neodesat);
-    neo.heartbeat(neopixel_pin >= 0);
-}
-void enable_flashdemo(bool ena) {
-    if (ena) {
-        neo.setflash(4, 8, 8, 8, 20, -1);  // brightness toggle in a continuous squarewave
-        neo.setflash(5, 3, 1, 2, 85);      // three super-quick bright white flashes
-        neo.setflash(6, 2, 5, 5, 0, 0);    // two short black pulses
-    }
-    else {
-        neo.setflash(4, 0);
-        neo.setflash(5, 0);
-        neo.setflash(6, 0);
-    }
-}
-// Calculates massairflow in g/s using values passed in if present, otherwise it reads fresh values
-float massairflow(float _map = NAN, float _airvelo = NAN, float _ambient = NAN) {  // mdot (kg/s) = density (kg/m3) * v (m/s) * A (m2) .  And density = P/RT.  So,   mdot = v * A * P / (R * T)  in kg/s
-    float temp = _ambient;
-    if (std::isnan(_ambient)) {
-        temp = tempsens.val(loc::ambient);
-        if (std::isnan(temp) && running_on_devboard) temp = tempsens.val(loc::engine);
-        if (std::isnan(temp)) return -1;  // Avoid crashing due to trying to read absent sensor
-    }
-    float T = 0.556 * (temp - 32.0) + 273.15;  // in K.  This converts from degF to K
-    float R = 287.1;  // R (for air) in J/(kgK) ( equivalent to 8.314 J/(molK) )  1 J = 1 kg*m2/s2
-    float v = 0.447 * (std::isnan(_airvelo) ? airvelo.filt() : _airvelo); // in m/s   1609.34 m/mi * 1/3600 hr/s = 0.447
-    float Ain2 = 3.1415926;  // in in2    1.0^2 in2 * pi  // will still need to divide by 1550 in2/m2
-    float P = 6894.76 * (std::isnan(_map) ? mapsens.filt() : _map);  // in Pa   6894.76 Pa/PSI  1 Pa = 1 J/m3
-    return v * Ain2 * P * 1000.0 / (R * T * 1550);  // mass air flow in grams per second (ug/s)   (1k g/kg * m/s * in2 * J/m3) / (J/(kg*K) * K * 1550 in2/m2) = g/s
-}
-float maf_gps;  // Manifold mass airflow in grams per second
-float maf_min_gps = 0.0;
-float maf_max_gps = massairflow(mapsens.max_psi(), airvelo.max_mph(), temp_lims_f[AMBIENT][DISP_MIN]);
-
-#define RUN_TESTS 0
-#if RUN_TESTS
-    #include "unittests.h"
-    void run_tests() {
-        printf("Running tests...\n");
-        delay(5000);
-        test_Param();
-        printf("Tests complete.\n");
-        for(;;) {} // loop forever
-    }
-#else
-    void run_tests() {}
-#endif
+// globals.h - not dependent on anything, so include this first
+#pragma once
+#include <Wire.h>
+#include "Arduino.h"
+// #include <cstdint> // for uint types
+// #include <cstdio> // for printf
+// pin assignments  ESP32-S3-DevkitC series
+#define      button_pin  0 // button0/strap-1  // Input, Rotary encoder push switch, for the UI. active low (needs pullup). Also the esp "Boot" button does the same thing
+#define    lipobatt_pin  1 // adc1ch0          // Analog input, LiPo cell voltage, full scale is 4.8V
+#define   encoder_b_pin  2 // adc1ch1          // Int input, The B (aka DT) pin of the encoder. Both A and B complete a negative pulse in between detents. If B pulse goes low first, turn is CW. (needs pullup)
+#define      tft_dc_pin  3 // adc1ch2/strap-X  // Output, Assert when sending data to display chip to indicate commands vs. screen data - ! pin is also defined in tft_setup.h
+#define    mulebatt_pin  4 // adc1ch3          // Analog input, mule battery voltage sense, full scale is 16V
+#define    pot_wipe_pin  5 // adc1ch4          // Analog in from 20k pot
+#define   brake_pos_pin  6 // adc1ch5          // Analog input, tells us linear position of brake actuator. Blue is wired to ground, POS is wired to white.
+#define    pressure_pin  7 // adc1ch6          // Analog input, tells us brake fluid pressure. Needs a R divider to scale max possible pressure (using foot) to 3.3V.
+#define     i2c_sda_pin  8 // i2c0sda/adc1ch7  // i2c bus for airspeed/map sensors, lighting board, cap touchscreen
+#define     i2c_scl_pin  9 // i2c0scl/adc1ch8  // i2c bus for airspeed/map sensors, lighting board, cap touchscreen
+#define      tft_cs_pin 10 // spi0cs/adc1ch9   // Output, active low, Chip select allows ILI9341 display chip use of the SPI bus - ! pin is also defined in tft_setup.h
+#define    spi_mosi_pin 11 // spi0mosi/adc2ch0 // Used as spi interface data for touchscreen, sd card and tft screen - ! pin is also defined in tft_setup.h
+#define    spi_sclk_pin 12 // spi0sclk/adc2ch1 // Used as spi interface clock for touchscreen, sd card and tft screen - ! pin is also defined in tft_setup.h
+#define    spi_miso_pin 13 // spi0miso/adc2ch2 // Used as spi interface data from sd card and possibly (?) tft screen - ! pin is also defined in tft_setup.h
+#define hotrc_ch2_v_pin 14 // pwm0/adc2ch3     // Hotrc Ch2 bidirectional trigger input
+#define hotrc_ch1_h_pin 15 // pwm1/adc2ch4     // Hotrc Ch1 thumb joystick input
+#define     gas_pwm_pin 16 // pwm1/adc2ch5     // Output, PWM signal duty cycle controls throttle target. On Due this is the pin labeled DAC1 (where A13 is on Mega)
+#define   brake_pwm_pin 17 // pwm0/adc2ch6/tx1 // Output, PWM signal duty cycle sets speed of brake actuator from full speed extend to full speed retract, (50% is stopped)
+#define   steer_pwm_pin 18 // pwm0/adc2ch7/rx1 // Output, PWM signal positive pulse width sets steering motor speed from full left to full speed right, (50% is stopped). Jaguar asks for an added 150ohm series R when high is 3.3V
+#define steer_enc_a_pin 19 // usb-d-/adc2ch8   // Reserved for a steering quadrature encoder. Encoder "A" signal
+#define steer_enc_b_pin 20 // usb-d+/adc2ch9   // Reserved for a steering quadrature encoder. Encoder "B" signal
+#define     onewire_pin 21 // pwm0             // Onewire bus for temperature sensor data. note: tested this does not work on higher-numbered pins (~35+)
+#define      speedo_pin 35 // spiram/octspi    // Int Input, active high, asserted when magnet South is in range of sensor. 1 pulse per driven pulley rotation. (Open collector sensors need pullup)
+#define     starter_pin 36 // sram/ospi/glitch // Input/Output (both active high), output when starter is being driven, otherwise input senses external starter activation
+#define        tach_pin 37 // spiram/octspi    // Int Input, active high, asserted when magnet South is in range of sensor. 1 pulse per engine rotation. (no pullup) - Note: placed on p36 because filtering should negate any effects of 80ns low pulse when certain rtc devices power on (see errata 3.11)
+#define   sdcard_cs_pin 38 // spiram/octspi    // Output, chip select for SD card controller on SPI bus
+#define basicmodesw_pin 39 // jtck/glitch      // Input, asserted to tell us to run in basic mode, active low (has ext pullup) - Note: placed on p39 because filtering should negate any effects of 80ns low pulse when certain rtc devices power on (see errata 3.11)
+#define   hotrc_ch4_pin 40 // jtdo             // Syspower, starter, and cruise mode toggle control. Hotrc Ch4 PWM toggle signal
+#define   hotrc_ch3_pin 41 // jtdi             // Ignition control, Hotrc Ch3 PWM toggle signal
+#define   encoder_a_pin 42 // jtms             // Int input, The A (aka CLK) pin of the encoder. Both A and B complete a negative pulse in between detents. If A pulse goes low first, turn is CCW. (needs pullup)
+#define     uart_tx_pin 43 // "TX"/uart0tx     // Serial monitor data out. Also used to detect devboard vs. pcb at boot time (using pullup/pulldown, see below)
+#define     uart_rx_pin 44 // "RX"/uart0rx     // Serial monitor data in. Maybe could repurpose during runtime since we only need outgoing console data?
+#define    ignition_pin 45 // strap-0          // Output to an nfet/pfet pair to control the car ignition
+#define    syspower_pin 46 // strap-0          // Output to an nfet/pfet pair to power all the tranducers.
+#define    touch_cs_pin 47 // NA               // Output, chip select for resistive touchscreen, active low - ! pin is also defined in tft_setup.h
+#define    neopixel_pin 48 // neopix           // Data line to onboard Neopixel WS281x (on all v1 devkit boards - pin 38 is used on v1.1 boards). Also used for onboard and external neopoxels - ! pin is also defined in neopixel.h
+// External components needed (pullup/pulldown resistors, capacitors, etc.): (Note: "BB" = On dev breadboards only, "PCB" = On vehicle PCB only)
+// 1. brake_pos_pin: Add 1M-ohm to GND. Allows detecting unconnected sensor or broken connection.
+// 2. onewire_pin: Add 4.7k-ohm to 3.3V. Needed for open collector sensor output, to define logic-high voltage level.
+// 3. tach_pin, speedo_pin: (PCB) Add 4.7k-ohm to 3.3V. For open collector sensor outputs. (BB) If no sensor is present: connect 4.7k-ohm to GND instead. Allows sensor detection.
+// 4. neopixel_pin: (PCB) Add 330 ohm in series (between pin and the DataIn pin of the 1st pixel). (BB) Same, but this one is likely optional, e.g. mine works w/o it.  For signal integrity over long wires. 
+// 5. uart_tx_pin: (PCB) Add 22k-ohm to GND. (BB) Connect the 22k-ohm to 3.3V instead. For boot detection of vehicle PCB, so defaults are set appropriately.
+// 6. ADC inputs (mulebatt_pin, pressure_pin, brake_pos_pin, pot_wipe_pin) should have 100nF cap to gnd, tho it works w/o it.
+// 7. encoder_a_pin, encoder_b_pin, button_pin: should have 10nF to gnd, tho it should work w/o it. Pullups to 3.3V (4.7k-ohm is good) are also necessary, but the encoder we're using includes these.
+// 8. Resistor dividers are needed for these inputs: starter_pin (16V->3.3V), mulebatt_pin (16V->3.3V), and pressure_pin (5V->3.3V).
+// 9. ignition_pin, syspower_pin, starter_pin: require pulldowns to gnd, this is provided by nfet gate pulldown.
+// 10. gas_pwm_pin: should have a series ~680-ohm R going to the servo.
+
+// Note onewire works on pins 19-21 but not on pins 39-42
+// If one more pin becomes needed, encoder_sw may be moved to pin 0, freeing up pin 38 (pin 0 requires a pullup, which encoder_sw has)
+// ESP32-S3 TRM: https://www.espressif.com/sites/default/files/documentation/esp32-s3_technical_reference_manual_en.pdf#dma
+// ESP32-S3 Datasheet: https://www.espressif.com/sites/default/files/documentation/esp32-s3_datasheet_en.pdf
+// ESP32-S3 has 5 DMA channels in each direction. We would use them for SPI data out to TFT, Neopixel data out, and possibly out to the 3 motor outputs and in from the 4 hotrc channels.
+// DMA works with: RMT, I2S0, I2S1, SPI2, SPI3, ADC, internal RAM, external PSRAM, and a few others (see the TRM)
+// Official pin capabilities: https://docs.espressif.com/projects/esp-idf/en/latest/esp32s3/hw-reference/esp32s3/user-guide-devkitc-1.html?highlight=devkitc#user-guide-s3-devkitc-1-v1-1-header-blocks
+// ADC ch2 will not work if wifi is enabled
+// Bootstrap pins: Pin 0 must be pulled high, and pins 45 and 46 pulled low during bootup
+// ESP32 errata 3.11: Pin 36 and 39 will be pulled low for ~80ns when "certain RTC peripherals power up"
+// SPI bus page including DMA information: https://docs.espressif.com/projects/esp-idf/en/v4.4/esp32s3/api-reference/peripherals/spi_master.html
+// BM2023 pins: onewire 19, hotrc_ch3_pin 20, hotrc_ch4_pin 21, tach_pin 36, ignition_pin 37, encoder_b_pin 40, encoder_a_pin 41, encoder_sw_pin 42
+
+#define tft_ledk_pin -1   // Output, optional PWM signal to control brightness of LCD backlight (needs modification to shield board to work)
+#define touch_irq_pin 255 // Input, optional touch occurence interrupt signal (for resistive touchscreen, prevents spi bus delays) - Set to 255 if not used
+#define tft_rst_pin -1    // TFT Reset allows us to reboot the screen hardware when it crashes. Otherwise connect screen reset line to esp reset pin
+
+#define adcbits 12
+#define adcrange_adc 4095     // = 2^adcbits-1
+#define adcmidscale_adc 2047  // = 2^(adcbits-1)-1
+
+// fast macros
+#define arraysize(x) ((int32_t)(sizeof(x) / sizeof((x)[0])))  // A macro function to determine the length of string arrays
+#define floor(amt, lim) ((amt <= lim) ? lim : amt)
+#define ceiling(amt, lim) ((amt >= lim) ? lim : amt)
+#undef min
+#undef max
+// these global enums are super convenient, just take care when making changes
+// it's good to keep global enums in one place here
+enum hotrc_axis : int { horz=0, vert=1, ch3=2, ch4=3 };
+enum hotrc_val : int { opmin=0, cent=1, opmax=2, raw=3, filt=4, dbbot=5, dbtop=6, margin=7 };
+enum motor_val : int { parked=1, out=3, govern=4 , absmin=5, absmax=6};
+enum stop_val : int { stop=1 };
+enum steer_val : int { safe=1 };
+enum size_enums : int { num_axes=2, num_chans=4, num_motorvals=7, num_valus=8 };
+enum joydirs : int { joy_rt=-2, joy_down=-1, joy_cent=0, joy_up=1, joy_lt=2 };
+enum runmode : int { BASIC, ASLEEP, SHUTDOWN, STALL, HOLD, FLY, CRUISE, CAL, num_runmodes };
+enum req : int { req_na=-1, req_off=0, req_on=1, req_tog=2 };  // requesting handler actions of digital values with handler functions
+enum cruise_modes : int { pid_suspend_fly, throttle_angle, throttle_delta };
+enum sw_presses : int { NONE, SHORT, LONG }; // used by encoder sw and button algorithms
+enum temp_categories : int { AMBIENT = 0, ENGINE = 1, WHEEL = 2, num_temp_categories };
+enum temp_lims : int { DISP_MIN, OP_MIN, OP_MAX, WARNING, ALARM, DISP_MAX }; // Possible sources of gas, brake, steering commands
+
+// global configuration settings
+bool starter_signal_support = true;
+bool remote_start_support = true;
+bool autostop_disabled = false;      // Temporary measure to keep brake behaving until we get it debugged. Eventually should be false
+bool allow_rolling_start = false;    // May be a smart prerequisite, may be us putting obstacles in our way
+bool flip_the_screen = true;
+bool cruise_speed_lowerable = true;  // Allows use of trigger to adjust cruise speed target without leaving cruise mode.  Otherwise cruise button is a "lock" button, and trigger activity cancels lock
+// Dev-board-only options:  Note these are ignored and set false at boot by set_board_defaults() unless running on a breadboard with a 22k-ohm pullup to 3.3V the TX pin
+bool usb_jtag = true;  // If you will need the usb otg port for jtag debugging (see https://docs.espressif.com/projects/esp-idf/en/latest/esp32s3/api-guides/jtag-debugging/configure-builtin-jtag.html)
+bool dont_take_temperatures = false; // In case debugging dallas sensors or causing problems
+bool console_enabled = true;         // safer to disable because serial printing itself can easily cause new problems, and libraries might do it whenever
+bool keep_system_powered = false;    // Use true during development
+bool screensaver = false;            // Can enable experiment with animated screen draws
+bool looptime_print = false;         // Makes code write out timestamps throughout loop to serial port
+bool touch_reticles = false;
+
+// global tunable variables
+uint32_t looptime_linefeed_threshold = 0;  // when looptime_print == 1, will linefeed after printing loops taking > this value. Set to 0 linefeeds all prints
+uint32_t starter_timeout_us = 5000000;  // How long to run starter before automatically stopping it
+uint32_t panic_relax_timeout_us = 20000000;  // How long to panic before getting over it and moving on
+float flycruise_vert_margin_pc = 0.3; // Margin of error for determining hard brake value for dropping out of cruise mode
+// Cruise : is active on demand while driving.
+// Pick from 3 different styles for adjustment of cruise setpoint. I prefer throttle_delta.
+// pid_suspend_fly : (PID) Moving trigger from center pauses the pid and lets you adjust the rpm target directly like Fly mode does. Whatever speed you're at when trigger releases is new pid target  
+// throttle_angle : Cruise locks throttle angle, instead of pid. Moving trigger from center adjusts setpoint proportional to how far you push it before releasing (and reduced by an attenuation factor)
+// throttle_delta : Cruise locks throttle angle, instead of pid. Any non-center trigger position continuously adjusts setpoint proportional to how far it's pulled over time (up to a specified maximum rate)
+int cruise_setpoint_mode = throttle_delta;
+int32_t cruise_delta_max_pc_per_s = 16;  // (in throttle_delta mode) What's the fastest rate cruise adjustment can change pulse width (in us per second)
+float cruise_angle_attenuator = 0.016;  // (in throttle_angle mode) Limits the change of each adjust trigger pull to this fraction of what's possible
+float temp_lims_f[3][6]{
+    {0.0, 45.0, 115.0, 120.0, 130.0, 220.0},  // [AMBIENT][DISP_MIN/OP_MIN/OP_MAX/WARNING/ALARM]
+    {0.0, 178.0, 198.0, 202.0, 205.0, 220.0}, // [ENGINE][DISP_MIN/OP_MIN/OP_MAX/WARNING/ALARM]
+    {0.0, 50.0, 120.0, 130.0, 140.0, 220.0},  // [WHEEL][DISP_MIN/OP_MIN/OP_MAX/WARNING/ALARM] (applies to all wheels)
+};
+float temp_room = 77.0;          // "Room" temperature is 25 C = 77 F  Who cares?
+float temp_sensor_min_f = -67.0; // Minimum reading of sensor is -25 C = -67 F
+float temp_sensor_max_f = 257.0; // Maximum reading of sensor is 125 C = 257 F
+float maf_min_gps = 0.0;
+float maf_max_gps = 50.0;  // i just made this number up as i have no idea what's normal for MAF
+int16_t touch_pt[4] = { 160, 120, 2230, 2130 };
+bool flashdemo = false;
+int32_t neobright = 10;  // default for us dim/brighten the neopixels
+int32_t neodesat = 0;  // default for lets us de/saturate the neopixels
+
+// non-tunable vlaues. probably these belong with their related code
+bool running_on_devboard = false;    // will overwrite with value read thru pull resistor on tx pin at boot
+bool shutdown_incomplete = true;     // minor state variable for shutdown mode - Shutdown mode has not completed its work and can't yet stop activity
+bool park_the_motors = false;        // Indicates we should release the brake & gas so the pedals can be used manually without interference
+bool cruise_adjusting = false;
+bool cal_joyvert_brkmotor_mode = false; // Allows direct control of brake motor using controller vert
+bool cal_pot_gasservo_ready = false;    // Whether pot is in valid range
+bool cal_pot_gasservo_mode = false;     // Allows direct control of gas servo using pot. First requires pot to be in valid position before mode is entered
+bool autostopping = false; // true when in process of stopping the car (hold or shutdown modes)
+bool car_hasnt_moved = false;        // minor state variable for fly mode - Whether car has moved at all since entering fly mode
+bool powering_up = false;  // minor state variable for asleep mode
+bool calmode_request = false;
+int sleep_request = req_na;
+
+inline float smax(float a, float b) { return (a > b) ? a : b; }
+inline int32_t smax(int32_t a, int32_t b) { return (a > b) ? a : b; }
+inline uint32_t smax(uint32_t a, uint32_t b) { return (a > b) ? a : b; }
+inline uint32_t smax(uint32_t a, uint32_t b, uint32_t c) { return (a > b) ? ((c > a) ? c : a) : ((c > b) ? c : b); }
+inline float smin(float a, float b) { return (a < b) ? a : b; }
+inline int32_t smin(int32_t a, int32_t b) { return (a < b) ? a : b; }
+inline uint32_t smin(uint32_t a, uint32_t b) { return (a < b) ? a : b; }
+inline uint32_t smin(uint32_t a, uint32_t b, uint32_t c) { return (a < b) ? ((c < a) ? c : a) : ((c < b) ? c : b); }
+#undef constrain
+inline float constrain(float amt, float low, float high) { return (amt < low) ? low : ((amt > high) ? high : amt); }
+inline int32_t constrain(int32_t amt, int32_t low, int32_t high) { return (amt < low) ? low : ((amt > high) ? high : amt); }
+inline uint32_t constrain(uint32_t amt, uint32_t low, uint32_t high) { return (amt < low) ? low : ((amt > high) ? high : amt); }
+inline long constrain(long amt, long low, long high) { return (amt < low) ? low : ((amt > high) ? high : amt); }
+// the above should be templated, i'm sure. i tried the following but it didn't work
+// template <typename T> inline T smax(T a, T b) { return (a > b) ? a : b; }
+// template <typename T> inline T smax(T a, T b, T c) { return (a > b) ? ((c > a) ? c : a) : ((c > b) ? c : b); }
+// template <typename T> inline T smin(T a, T b) { return (a < b) ? a : b; }
+// template <typename T> inline T smin(T a, T b, T c) { return (a < b) ? ((c < a) ? c : a) : ((c < b) ? c : b); }
+// template <typename T> inline T constrain(T amt, T low, T high) { return (amt < low) ? low : ((amt > high) ? high : amt); }
+// template <typename T> inline T map(T x, T in_min, T in_max, T out_min, T out_max) {
+//     if (in_max - in_min > (T)0.001) return out_min + (x - in_min) * (out_max - out_min) / (in_max - in_min);
+//     printf ("map not dividing by zero\n");
+//     return out_max;  // Instead of dividing by zero, return the highest valid result
+// }
+
+#undef map
+inline float map(float x, float in_min, float in_max, float out_min, float out_max) {
+    if (in_max - in_min) return out_min + (x - in_min) * (out_max - out_min) / (in_max - in_min);
+    return out_max;  // Instead of dividing by zero, return the highest valid result
+}
+inline int32_t map(int32_t x, int32_t in_min, int32_t in_max, int32_t out_min, int32_t out_max) {
+    if (in_max - in_min) return out_min + (x - in_min) * (out_max - out_min) / (in_max - in_min);
+    return out_max;  // Instead of dividing by zero, return the highest valid result
+}
+bool rounding = true;
+float dround(float val, int32_t digits) { return (rounding) ? (std::round(val * std::pow (10, digits)) / std::pow (10, digits)) : val; }
+
+// pin operations
+void set_pin(int32_t pin, int32_t mode) { if (pin >= 0 && pin != 255) pinMode (pin, mode); }
+void write_pin(int32_t pin, int32_t val) {  if (pin >= 0 && pin != 255) digitalWrite (pin, val); }
+int32_t read_pin(int32_t pin) { return (pin >= 0 && pin != 255) ? digitalRead (pin) : -1; }
+
+float convert_units(float from_units, float convert_factor, bool invert, float in_offset = 0.0, float out_offset = 0.0) {
+    if (!invert) return out_offset + convert_factor * (from_units - in_offset);
+    if (from_units - in_offset) return out_offset + convert_factor / (from_units - in_offset);
+    printf ("convert_units refused to divide by zero: %lf, %lf, %d, %lf, %lf", from_units, convert_factor, invert, in_offset, out_offset);
+    return -1;
+}
+
+// Exponential Moving Average filter : Smooth out noise on inputs. 0 < alpha < 1 where lower = smoother and higher = more responsive
+// Pass in a fresh raw value, address of filtered value, and alpha factor, filtered value will get updated
+float ema_filt(float raw, float filt, float alpha) {
+    return (alpha * raw) + ((1 - alpha) * filt);
+}
+template<typename RAW_T, typename FILT_T>
+void ema_filt(RAW_T raw, FILT_T* filt, float alpha) {
+    float raw_f = static_cast<float>(raw);
+    float filt_f = static_cast<float>(*filt);
+    *filt = static_cast<FILT_T>(ema_filt(raw_f, filt_f, alpha));
+}
+
+// functions for changing values while respecting min and max constraints. used in tuner ui
+template <typename T>
+T adj_val(T variable, T modify, T low_limit, T high_limit) {
+    T oldval = variable;
+    variable += modify;
+    return variable < low_limit ? low_limit : (variable > high_limit ? high_limit : variable);
+}
+bool adj_val(int32_t *variable, int32_t modify, int32_t low_limit, int32_t high_limit) { // sets an int reference to new val constrained to given range
+    int32_t oldval = *variable;
+    *variable = adj_val(*variable, modify, low_limit, high_limit);
+    return (*variable != oldval);
+}
+bool adj_val(float *variable, float modify, float low_limit, float high_limit) { // sets an int reference to new val constrained to given range
+    float oldval = *variable;
+    *variable = adj_val(*variable, modify, low_limit, high_limit);
+    return (*variable != oldval);
+}
+bool adj_bool(bool val, int32_t delta) { return delta != 0 ? delta > 0 : val; } // returns 1 on delta=1, 0 on delta=-1, or val on delta=0
+void adj_bool(bool *val, int32_t delta) { *val = adj_bool(*val, delta); }       // sets a bool reference to 1 on 1 delta or 0 on -1 delta
+
+class Timer {  // !!! beware, this 54-bit microsecond timer overflows after every 571 years
+  protected:
+    volatile int64_t start_us, timeout_us;
+  public:
+    Timer() { reset(); }
+    Timer(int arg_timeout_us) { set ((int64_t)arg_timeout_us); }
+    void IRAM_ATTR set (int64_t arg_timeout_us) {
+        timeout_us = arg_timeout_us;
+        start_us = esp_timer_get_time();
+    }
+    void IRAM_ATTR reset() { start_us = esp_timer_get_time(); }
+    bool IRAM_ATTR expired() { return esp_timer_get_time() >= start_us + timeout_us; }
+    bool IRAM_ATTR expireset() {  // Like expired() but immediately resets if expired
+        int64_t now_us = esp_timer_get_time();
+        if (now_us < start_us + timeout_us) return false;
+        start_us = now_us;
+        return true;
+    }    
+    int64_t IRAM_ATTR elapsed() { return esp_timer_get_time() - start_us; }
+    int64_t IRAM_ATTR timeout() { return timeout_us; }
+};
+class I2C {
+    private:
+        int32_t _devicecount = 0;
+        uint8_t _addrs[10];
+        uint8_t _sda_pin, _scl_pin;
+        Timer scanTimer;
+    public:
+        I2C(uint8_t sda_pin_arg, uint8_t scl_pin_arg) : _sda_pin(sda_pin_arg), _scl_pin(scl_pin_arg) {}
+
+        void init() {
+            printf("I2C driver ");
+            scanTimer.reset();
+            Wire.begin(_sda_pin, _scl_pin);  // I2c bus needed for airflow sensor
+            byte error, address;
+            printf(" scanning ...");
+            _devicecount = 0;
+            for (address = 1; address < 127; address++ ) {
+                Wire.beginTransmission(address);
+                error = Wire.endTransmission();
+                if (error == 0) {
+                    printf (" found addr: 0x%s%x", (address < 16) ? "0" : "", address);
+                    _addrs[_devicecount++] = address;
+                }
+                else if (error==4) printf (" error addr: 0x%s%x", (address < 16) ? "0" : "", address);
+            }
+            if (scanTimer.elapsed() > 5000000) printf(" timeout & fail bus scan.");
+            if (_devicecount == 0) printf(" no devices found.");
+            printf(" done\n");
+        }
+
+        bool device_detected(uint8_t addr) {
+            for (int32_t i=0; i < _devicecount; i++) {
+                if (_addrs[i] == addr) return true;
+            }
+            return false;
+        }
+};
\ No newline at end of file
diff --git a/CANTroller2/src/motors.h b/CANTroller2/src/motors.h
index 2d6b462..47cef20 100644
--- a/CANTroller2/src/motors.h
+++ b/CANTroller2/src/motors.h
@@ -192,10 +192,8 @@ class ServoMotor {
     int pin;
     uint32_t pid_period_us = 85000;
   public:
-    bool open_loop = true, motor_reversed = false;
-    float pc[num_motorvals] = { 0, NAN, 100, NAN, NAN, NAN, NAN };  // percent values [opmin/parked/opmax/out/govern/absmin/absmax]  values range from -100% to 100% are all derived or auto-assigned
-    float nat[num_motorvals] = { 45.0, 43.0, 168.2, 45.0, NAN, 0, 180 };  // native-unit values [opmin/parked/opmax/out/govern/absmin/absmax]
-    float us[num_motorvals] = { NAN, 1500, NAN, NAN, NAN, 500, 2500 };  // us pulsewidth values [-/cent/-/out/-/absmin/absmax]
+    bool openloop = false, reverse = false;  // defaults. subclasses override as necessary
+    float pc[num_motorvals], nat[num_motorvals], us[num_motorvals];  // subclasses initialize these with tuned values
     void init(int _pin, int _freq, Hotrc* _hotrc, Speedometer* _speedo) {
         this->hotrc = _hotrc;
         this->speedo = _speedo;
@@ -211,10 +209,10 @@ class ServoMotor {
         return map(_nat, this->nat[absmin], this->nat[absmax], this->pc[absmin], this->pc[absmax]);
     }
     float nat_to_us(float _nat) {  // works for motor with or without stop value
-        return map(_nat, this->nat[absmin], this->nat[absmax], this->motor_reversed ? this->us[absmax] : this->us[absmin], this->motor_reversed ? this->us[absmin] : this->us[absmax]);
+        return map(_nat, this->nat[absmin], this->nat[absmax], this->reverse ? this->us[absmax] : this->us[absmin], this->reverse ? this->us[absmin] : this->us[absmax]);
     }
     float pc_to_us(float _pc) {  // works for motor with or without stop value
-        return map(_pc, this->pc[absmin], this->pc[absmax], this->motor_reversed ? this->us[absmax] : this->us[absmin], this->motor_reversed ? this->us[absmin] : this->us[opmax]);
+        return map(_pc, this->pc[absmin], this->pc[absmax], this->reverse ? this->us[absmax] : this->us[absmin], this->reverse ? this->us[absmin] : this->us[absmax]);
     }
     void write_motor() {
         this->motor.writeMicroseconds((int32_t)(this->us[out]));
@@ -233,8 +231,12 @@ class GasServo : public ServoMotor {
     float initial_ki = 0.000;  // PID integral frequency factor (gas). How much more to open throttle for each unit time trying to reach desired RPM  (in 1/us (mhz), range 0-1)
     float initial_kd = 0.000;  // PID derivative time factor (gas). How much to dampen sudden throttle changes due to P and I infuences (in us, range 0-1)
   public:
-    float (&deg)[arraysize(nat)] = nat;  // our "native" value is degrees of rotation "deg"
-    qpid pid, cruisepid;
+    bool openloop = true, reverse = false;  // if servo higher pulsewidth turns ccw, then do reverse=true
+    float pc[num_motorvals] = { 0, NAN, 100, NAN, NAN, NAN, NAN };  // percent values [opmin/parked/opmax/out/govern/absmin/absmax]  values range from -100% to 100% are all derived or auto-assigned
+    float nat[num_motorvals] = { 45.0, 43.0, 168.2, 45.0, NAN, 0, 180 };  // native-unit values [opmin/parked/opmax/out/govern/absmin/absmax]
+    float us[num_motorvals] = { NAN, 1500, NAN, NAN, NAN, 500, 2500 };  // us pulsewidth values [-/cent/-/out/-/absmin/absmax]
+    float (&deg)[arraysize(nat)] = nat;  // our "native" value is degrees of rotation "deg". Create reference so nat and deg are interchangeable
+    QPID pid, cruisepid;
     float cruise_target_pc, governor = 95;     // Software governor will only allow this percent of full-open throttle (percent 0-100)
     Timer servo_delay_timer;    // We expect the servo to find any new position within this time
     GasServo() {};  // Brake(int8_t _motor_pin, int8_t _press_pin, int8_t _posn_pin); 
@@ -250,47 +252,47 @@ class GasServo : public ServoMotor {
         tach = _tach;
         pot = _pot;
         throttle = _throttle;
-        pid.init(tach->filt_ptr(), 0.0, 100.0, initial_kp, initial_ki, initial_kd, qpid::pmod::onerr, qpid::dmod::onerr, 
-            qpid::awmod::clamp, qpid::cdir::direct, pid_period_us);
+        pid.init(tach->filt_ptr(), 0.0, 100.0, initial_kp, initial_ki, initial_kd, QPID::pmod::onerr, QPID::dmod::onerr, 
+            QPID::awmod::clamp, QPID::cdir::direct, pid_period_us);
         cruisepid.init(speedo->filt_ptr(), throttle->idle_rpm, tach->govern_rpm(), cruise_initial_kp, cruise_initial_ki, cruise_initial_kd,
-            qpid::pmod::onerr, qpid::dmod::onerr, qpid::awmod::round, qpid::cdir::direct, pid_period_us);
+            QPID::pmod::onerr, QPID::dmod::onerr, QPID::awmod::round, QPID::cdir::direct, pid_period_us);
         servo_delay_timer.set(servo_delay_us);
         derive();
     }
-    void update(int _runmode) {
+    void update(int runmode) {
         if (pid_timer.expireset()) {
             // Step 1 : update throttle target from idle control or cruise mode pid, if applicable (on the same timer as gas pid)
             throttle->update();  // Allow idle control to mess with tach_target if necessary, or otherwise step in to prevent car from stalling
-            if (_runmode == CRUISE && (cruise_setpoint_mode == pid_suspend_fly) && !cruise_adjusting) {
+            if (runmode == CRUISE && (cruise_setpoint_mode == pid_suspend_fly) && !cruise_adjusting) {
                 cruisepid.set_outlimits(throttle->idle_rpm, tach->govern_rpm());  // because cruise pid has internal variable for idlespeed which may need updating
                 pid.set_target(cruisepid.compute());  // cruise pid calculates new output (tach_target_rpm) based on input (speedmeter::human) and target (speedo_target_mph)
             }
             // Step 2 : Determine servo pulse width value
-            if (park_the_motors || (_runmode == SHUTDOWN && !shutdown_incomplete) || _runmode == ASLEEP)
+            if (park_the_motors || (runmode == SHUTDOWN && !shutdown_incomplete) || runmode == ASLEEP)
                 pc[out] = pc[parked];
-            else if (_runmode == CAL && cal_pot_gasservo_mode)
+            else if (runmode == CAL && cal_pot_gasservo_mode)
                 pc[out] = nat_to_pc(map(pot->val(), pot->min(), pot->max(), deg[absmin], deg[absmax]));  // gas_ccw_max_us, gas_cw_min_us
-            else if (_runmode == CRUISE && (cruise_setpoint_mode != pid_suspend_fly))
+            else if (runmode == CRUISE && (cruise_setpoint_mode != pid_suspend_fly))
                 pc[out] = cruise_target_pc;
-            else if (_runmode == STALL || (open_loop && _runmode != BASIC)) {  // Stall mode runs the gas servo directly proportional to joystick. This is truly open loop
+            else if (runmode == STALL || (openloop && runmode != BASIC)) {  // Stall mode runs the gas servo directly proportional to joystick. This is truly open loop
                 if (hotrc->joydir() != joy_up) pc[out] = pc[opmin];  // If in deadband or being pushed down, we want idle
                 else pc[out] = map(hotrc->pc[vert][filt], hotrc->pc[vert][dbtop], hotrc->pc[vert][opmax], pc[opmin], pc[govern]);  // actuators still respond even w/ engine turned off
             }
-            else if (_runmode != BASIC) {
+            else if (runmode != BASIC) {
                 pc[out] = pid.compute();  // Do proper pid math to determine gas_out_us from engine rpm error
             }
             // Step 3 : Convert to degrees and constrain if out of range
             deg[out] = pc_to_nat(pc[out]);  // convert to degrees
-            if (_runmode == CAL && cal_pot_gasservo_mode)  // Constrain to operating limits. 
+            if (runmode == CAL && cal_pot_gasservo_mode)  // Constrain to operating limits. 
                 deg[out] = constrain(deg[out], deg[absmin], deg[absmax]);
-            else if (_runmode == BASIC || _runmode == SHUTDOWN)
+            else if (runmode == BASIC || runmode == SHUTDOWN)
                 deg[out] = constrain(deg[out], deg[parked], nat[govern]);
             else deg[out] = constrain(deg[out], deg[opmin], deg[govern]);
             pc[out] = nat_to_pc(deg[out]);
             // Step 4 : Write to servo
             us[out] = nat_to_us(deg[out]);
-            if (!((_runmode == BASIC && !park_the_motors) || (_runmode == CAL && !cal_pot_gasservo_mode) 
-               || (_runmode == SHUTDOWN && !shutdown_incomplete) || (_runmode == ASLEEP)))
+            if (!((runmode == BASIC && !park_the_motors) || (runmode == CAL && !cal_pot_gasservo_mode) 
+               || (runmode == SHUTDOWN && !shutdown_incomplete) || (runmode == ASLEEP)))
                 write_motor();
         }
     }
@@ -302,17 +304,16 @@ class JagMotor : public ServoMotor {
     uint32_t volt_check_period_us = 3500000;
     Timer volt_check_timer;
   public:
-    float duty_pc = 100;
+    float duty_pc = 100;  // default. subclasses override as necessary
     float pc[num_motorvals] = { NAN, 0, NAN, NAN, NAN, -100, 100 };  // percent values [opmin/stop/opmax/out/-/absmin/absmax]  values range from -100% to 100% are all derived or auto-assigned
     float nat[num_motorvals] = { NAN, 0, NAN, NAN, NAN, NAN, NAN };  // native-unit values [opmin/stop/opmax/out/-/absmin/absmax]
     float us[num_motorvals] = { NAN, 1500, NAN, NAN, NAN, 670, 2330 };  // us pulsewidth values [-/cent/-/out/-/absmin/absmax]
-    float (&volt)[arraysize(nat)] = this->nat;  // our "native" value is volts
-    bool motor_reversed = false;
+    float (&volt)[arraysize(nat)] = this->nat;  // our native value is volts. Create reference so nat and volt are interchangeable
     void derive() {  // calc pc and voltage op limits from volt and us abs limits 
         this->nat[absmax] = running_on_devboard ? this->car_batt_fake_v : this->mulebatt->v();
         this->nat[absmin] = -(this->nat[absmax]);
-        this->pc[opmin] = this->pc[absmin] * this->duty_pc / 100.0;
-        this->pc[opmax] = this->pc[absmax] * this->duty_pc / 100.0;
+        this->pc[opmin] = this->pc[stop] + (this->pc[absmin] - this->pc[stop]) * this->duty_pc / 100.0;
+        this->pc[opmax] = this->pc[stop] + (this->pc[absmax] - this->pc[stop]) * this->duty_pc / 100.0;
         this->nat[opmin] = map(this->pc[opmin], this->pc[stop], this->pc[absmin], this->nat[stop], this->nat[absmin]);
         this->nat[opmax] = map(this->pc[opmax], this->pc[stop], this->pc[absmax], this->nat[stop], this->nat[absmax]);
     }
@@ -332,14 +333,14 @@ class JagMotor : public ServoMotor {
         if (_nat < this->nat[stop]) return map(_nat, this->nat[stop], this->nat[absmin], this->pc[stop], this->pc[absmin]);
         return this->pc[stop];
     }
-    float nat_to_us(float _nat) {  // works for motor with or without stop value
-        if (_nat > this->nat[stop]) return map(_nat, this->nat[stop], this->nat[absmax], this->us[stop], this->motor_reversed ? this->us[absmin] : this->us[absmax]);
-        if (_nat < this->nat[stop]) return map(_nat, this->nat[stop], this->nat[absmin], this->us[stop], this->motor_reversed ? this->us[absmax] : this->us[absmin]);
+    float nat_to_us(float _nat) {  // works for motor with center stop value
+        if (_nat > this->nat[stop]) return map(_nat, this->nat[stop], this->nat[absmax], this->us[stop], this->reverse ? this->us[absmin] : this->us[absmax]);
+        if (_nat < this->nat[stop]) return map(_nat, this->nat[stop], this->nat[absmin], this->us[stop], this->reverse ? this->us[absmax] : this->us[absmin]);
         return this->us[stop];
     }
-    float pc_to_us(float _pc) {  // works for motor with or without stop value
-        if (_pc > this->pc[stop]) return map(_pc, this->pc[stop], this->pc[absmax], this->us[stop], this->motor_reversed ? this->us[absmin] : this->us[absmax]);
-        if (_pc < this->pc[stop]) return map(_pc, this->pc[stop], this->pc[absmin], this->us[stop], this->motor_reversed ? this->us[absmax] : this->us[absmin]);
+    float pc_to_us(float _pc) {  // works for motor with center stop value
+        if (_pc > this->pc[stop]) return map(_pc, this->pc[stop], this->pc[absmax], this->us[stop], this->reverse ? this->us[absmin] : this->us[absmax]);
+        if (_pc < this->pc[stop]) return map(_pc, this->pc[stop], this->pc[absmin], this->us[stop], this->reverse ? this->us[absmax] : this->us[absmin]);
         return this->us[stop];
     }
     void write_motor() {
@@ -348,21 +349,21 @@ class JagMotor : public ServoMotor {
 };
 class BrakeMotor : public JagMotor {
   public:
-    bool autostopping = false;
+    bool autostopping = false, reverse = false, openloop = false;
     float duty_pc = 25.0;
     Timer stopcar_timer, interval_timer;  // How much time between increasing brake force during auto-stop if car still moving?    // How long before giving up on trying to stop car?
-    qpid pid;
+    QPID pid;
     BrakeMotor() {}  // Brake(int8_t _motor_pin, int8_t _press_pin, int8_t _posn_pin); 
     void init(int _pin, int _freq, Hotrc* _hotrc, Speedometer* _speedo, CarBattery* _batt, PressureSensor* _pressure, BrakePositionSensor* _brakepos) {  // (int8_t _motor_pin, int8_t _press_pin, int8_t _posn_pin)
         JagMotor::init(_pin, _freq, _hotrc, _speedo, _batt);
         pressure = _pressure;  // press_pin = _press_pin;
         brakepos = _brakepos;  // posn_pin = _posn_pin;
-        pid.init(pressure->filt_ptr(), pc[opmin], pc[opmax], initial_kp, initial_ki, initial_kd, qpid::pmod::onerr, qpid::dmod::onerr,
-            qpid::awmod::cond, qpid::cdir::direct, pid_period_us, qpid::ctrl::manual, qpid::centmod::on, pc[stop]);
+        pid.init(pressure->filt_ptr(), pc[opmin], pc[opmax], initial_kp, initial_ki, initial_kd, QPID::pmod::onerr, QPID::dmod::onerr,
+            QPID::awmod::cond, QPID::cdir::direct, pid_period_us, QPID::ctrl::manual, QPID::centmod::on, pc[stop]);
         interval_timer.set(interval_timeout);
         stopcar_timer.set(stopcar_timeout);
     }
-    void update(int _runmode) {
+    void update(int runmode) {
         // Brakes - Determine motor output and write it to motor
         if (volt_check_timer.expireset()) derive();
         if (pid_timer.expireset()) {
@@ -373,19 +374,19 @@ class BrakeMotor : public JagMotor {
                 else if (brakepos->filt() - brakepos->margin() >= brakepos->parkpos())  // If brake is extended from park point, retract toward park point, slowing as we approach
                     pc[out] = map(brakepos->filt(), brakepos->parkpos(), brakepos->max_in(), pc[stop], pc[opmax]);
             }
-            else if (_runmode == CAL && cal_joyvert_brkmotor_mode) {
+            else if (runmode == CAL && cal_joyvert_brkmotor_mode) {
                 int _joydir = hotrc->joydir();
                 if (_joydir == joy_up) pc[out] = map(hotrc->pc[vert][filt], hotrc->pc[vert][dbtop], hotrc->pc[vert][opmax], pc[stop], pc[opmax]);
                 else if (_joydir == joy_down) pc[out] = map(hotrc->pc[vert][filt], hotrc->pc[vert][opmin], hotrc->pc[vert][dbbot], pc[opmin], pc[stop]);
                 else pc[out] = pc[stop];
             }
-            else if (_runmode == CAL || _runmode == BASIC || _runmode == ASLEEP || (_runmode == SHUTDOWN && !shutdown_incomplete))
+            else if (runmode == CAL || runmode == BASIC || runmode == ASLEEP || (runmode == SHUTDOWN && !shutdown_incomplete))
                 pc[out] = pc[stop];
             else {  // First attenuate max power to avoid blowing out the motor like in bm2023, if retracting, as a proportion of position from zeropoint to fully retracted
                 pc[out] = pid.compute();  // Otherwise the pid control is active
             }
             // Step 2 : Fix motor pc value if it's out of range or exceeding positional limits
-            if (_runmode == CAL && cal_joyvert_brkmotor_mode)  // Constrain the motor to the operational range, unless calibrating (then constraint already performed above)
+            if (runmode == CAL && cal_joyvert_brkmotor_mode)  // Constrain the motor to the operational range, unless calibrating (then constraint already performed above)
                 pc[out] = constrain(pc[out], pc[opmin], pc[opmax]);  // Constrain to full potential range when calibrating. Caution don't break anything!
             else if ((pc[out] < pc[stop] && brakepos->filt() > brakepos->parkpos() - brakepos->margin()) 
                   || (pc[out] > pc[stop] && brakepos->filt() < brakepos->min_in() + brakepos->margin()))  // If brake is at position limits and we're tring to go further, stop the motor
@@ -395,8 +396,8 @@ class BrakeMotor : public JagMotor {
             us[out] = pc_to_us(pc[out]);
             volt[out] = pc_to_nat(pc[out]);
             // Step 4 : Write to motor
-            if (!((_runmode == BASIC && !park_the_motors) || (_runmode == CAL && !cal_pot_gasservo_mode) 
-               || (_runmode == SHUTDOWN && !shutdown_incomplete) || (_runmode == ASLEEP)))
+            if (!((runmode == BASIC && !park_the_motors) || (runmode == CAL && !cal_pot_gasservo_mode) 
+               || (runmode == SHUTDOWN && !shutdown_incomplete) || (runmode == ASLEEP)))
                 write_motor();
         }
     }
@@ -418,15 +419,16 @@ class BrakeMotor : public JagMotor {
 };
 class SteerMotor : public JagMotor {
   public:
-    float steer_safe_pc = 72.0;
+    float steer_safe_pc = 28.0;  // this percent of full steering power when driving full speed (linearly applied)
+    bool reverse = false, openloop = true;
     SteerMotor() {}
     void init(int _pin, int _freq, Hotrc* _hotrc, Speedometer* _speedo, CarBattery* _batt) {  // (int8_t _motor_pin, int8_t _press_pin, int8_t _posn_pin)
         JagMotor::init(_pin, _freq, _hotrc, _speedo, _batt);
     }
-    void update(int _runmode) {
+    void update(int runmode) {
         if (volt_check_timer.expireset()) derive();
         if (pid_timer.expireset()) {
-            if (_runmode == ASLEEP || (_runmode == SHUTDOWN && !shutdown_incomplete)) pc[out] = pc[stop];  // Stop the steering motor if in shutdown mode and shutdown is complete
+            if (runmode == ASLEEP || (runmode == SHUTDOWN && !shutdown_incomplete)) pc[out] = pc[stop];  // Stop the steering motor if in shutdown mode and shutdown is complete
             else {
                 int _joydir = hotrc->joydir(horz);
                 if (_joydir == joy_rt) pc[out] = map(hotrc->pc[horz][filt], hotrc->pc[horz][dbtop], hotrc->pc[horz][opmax], pc[stop], steer_safe (pc[opmax]));  // if joy to the right of deadband
@@ -441,6 +443,6 @@ class SteerMotor : public JagMotor {
     }
   private:
     float steer_safe(float endpoint) {
-        return pc[stop] + (endpoint - pc[stop]) * (1.0 - steer_safe_pc * speedo->filt() / (100.0 * speedo->redline_mph()));
+        return pc[stop] + (endpoint - pc[stop]) * steer_safe_pc * speedo->filt() / (100.0 * speedo->redline_mph());
     }
-};
\ No newline at end of file
+};
diff --git a/CANTroller2/src/neopixel.h b/CANTroller2/src/neopixel.h
index 6b8095f..5cbeb21 100644
--- a/CANTroller2/src/neopixel.h
+++ b/CANTroller2/src/neopixel.h
@@ -5,7 +5,7 @@
 NeoPixelBus<NeoGrbFeature, NeoSk6812Method> neoobj(striplength, neopixel_pin);  // NeoWs2812Method, NeoWs2812xMethod, NeoSk6812Method, NeoEsp32Rmt0Ws2812xMethod, NeoEsp32I2s1800KbpsMethod, NeoEsp32I2s1Sk6812Method, 
 // Default for esp32 is dma via I2S bus 1 at 800kHz using RMT. Don't know the protocol difference between "Ws2812", "Ws2812x", and "Sk6812"
 // Run neos in a task example: https://github.com/Makuna/NeoPixelBus/wiki/ESP32-and-RTOS-Tasks
-class neopixelstrip {
+class NeopixelStrip {
   private:
     enum brightness_presets { B_OFF, B_MIN, B_LO, B_MED, B_HI, B_EXT, B_MAX };
     uint8_t neo_wheelcounter = 0;
@@ -67,7 +67,7 @@ class neopixelstrip {
     void update_idiot(uint32_t idiot);
     void calc_lobright();
   public:
-    neopixelstrip() {}
+    NeopixelStrip() {}
     void refresh();
     void init(uint8_t argpin, bool argbreadboard=false, bool viewcontext=NITE);
     void setbright(uint8_t bright_pc);
@@ -84,34 +84,34 @@ class neopixelstrip {
     uint32_t idiot_neo_color(uint8_t idiot);
 };
 
-uint32_t neopixelstrip::color_to_32b(colortype color) {  // Convert library color type to 32b 0xRRGGBB format
+uint32_t NeopixelStrip::color_to_32b(colortype color) {  // Convert library color type to 32b 0xRRGGBB format
     return (static_cast<uint32_t>(color.R) << 16) | (static_cast<uint32_t>(color.G) << 8) | static_cast<uint32_t>(color.B);  // (static_cast<uint32_t>(color.W) << 24) | 
 }
-uint32_t neopixelstrip::color_to_32b(uint16_t color565) {  // Convert 5-6-5 encoded 16-bit color value to 32b 0xRRGGBB format
+uint32_t NeopixelStrip::color_to_32b(uint16_t color565) {  // Convert 5-6-5 encoded 16-bit color value to 32b 0xRRGGBB format
     return ((uint32_t)color565 & 0xf800) << 8 | ((uint32_t)color565 & 0x7e0) << 5 | ((uint32_t)color565 & 0x1f) << 3;
 }
-colortype neopixelstrip::color_to_Rgb(uint32_t color) {  // Convert 32b 0xRRGGBB format color value to library color type
+colortype NeopixelStrip::color_to_Rgb(uint32_t color) {  // Convert 32b 0xRRGGBB format color value to library color type
     return colortype((color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff);  // (static_cast<uint32_t>(color.W) << 24) | 
 }
-colortype neopixelstrip::color_to_Rgb(uint16_t color565) {  // Convert 5-6-5 encoded 16-bit color value to library color type
+colortype NeopixelStrip::color_to_Rgb(uint16_t color565) {  // Convert 5-6-5 encoded 16-bit color value to library color type
     return colortype((color565 & 0xf800) >> 8, (color565 & 0x7e0) >> 3, (color565 & 0x1f) << 3);  // , 0);
 }
-uint16_t neopixelstrip::color_to_16b(uint32_t color) {  // Convert 32b 0xRRGGBB format color to 5-6-5 encoded 16-bit color value
+uint16_t NeopixelStrip::color_to_16b(uint32_t color) {  // Convert 32b 0xRRGGBB format color to 5-6-5 encoded 16-bit color value
     return (int16_t)(((color & 0xf80000) >> 8) | ((color & 0xfc00) >> 5) | (color & 0xf8) >> 3);
 }
-uint16_t neopixelstrip::color_to_16b(colortype color) {  // Convert library color type to 5-6-5 encoded 16-bit color value
+uint16_t NeopixelStrip::color_to_16b(colortype color) {  // Convert library color type to 5-6-5 encoded 16-bit color value
     return ((static_cast<uint16_t>(color.R) & 0xf8) << 8) | ((static_cast<uint16_t>(color.G) & 0xfc) << 3) | (((static_cast<uint16_t>(color.B) & 0xf8) >> 3));
 }
-float neopixelstrip::maxelement(float r, float g, float b) {
+float NeopixelStrip::maxelement(float r, float g, float b) {
     return (r > g) ? ((r > b) ? r : b) : ((g > b) ? g : b);  // (rgb[0] > rgb[1]) ? ((rgb[0] > rgb[2]) ? rgb[0] : rgb[2]) : ((rgb[1] > rgb[2]) ? rgb[1] : rgb[2]);  //smax(rgb[0], rgb[1], rgb[2]);  // (color.r > color.g) ? ((color.r > color.b) ? color.r : color.b) : ((color.g > color.b) ? color.g : color.b);
 }
-float neopixelstrip::midelement(float r, float g, float b) {
+float NeopixelStrip::midelement(float r, float g, float b) {
     return (r >= g) ? ((g >= b) ? g : ((r >= b) ? b : r)) : ((r >= b) ? r : ((b >= g) ? g : b));  // (rgb[0] > rgb[1]) ? ((rgb[0] > rgb[2]) ? rgb[0] : rgb[2]) : ((rgb[1] > rgb[2]) ? rgb[1] : rgb[2]);  //smax(rgb[0], rgb[1], rgb[2]);  // (color.r > color.g) ? ((color.r > color.b) ? color.r : color.b) : ((color.g > color.b) ? color.g : color.b);
 }
-float neopixelstrip::minelement(float r, float g, float b) {
+float NeopixelStrip::minelement(float r, float g, float b) {
     return (r < g) ? ((r < b) ? r : b) : ((g < b) ? g : b);  // (rgb[0] > rgb[1]) ? ((rgb[0] > rgb[2]) ? rgb[0] : rgb[2]) : ((rgb[1] > rgb[2]) ? rgb[1] : rgb[2]);  //smax(rgb[0], rgb[1], rgb[2]);  // (color.r > color.g) ? ((color.r > color.b) ? color.r : color.b) : ((color.g > color.b) ? color.g : color.b);
 }
-colortype neopixelstrip::dimmer(colortype color, uint8_t bright) {  // brightness 0 is off, 255 is max brightness while retaining same hue and saturation
+colortype NeopixelStrip::dimmer(colortype color, uint8_t bright) {  // brightness 0 is off, 255 is max brightness while retaining same hue and saturation
     int32_t ret[3];
     float rgb[3] = { static_cast<float>(color.R), static_cast<float>(color.G), static_cast<float>(color.B) };
     float fbright = (float)bright / maxelement(rgb[0], rgb[1], rgb[2]);  // smax(color.r, color.g, color.b);  // 2.55 = 0xff / 100
@@ -119,7 +119,7 @@ colortype neopixelstrip::dimmer(colortype color, uint8_t bright) {  // brightnes
     // printf("D br:%d  inc:%06x  outc:%02x%02x%02x\n", bright, color_to_32b(color), (uint8_t)ret[0], (uint8_t)ret[1], (uint8_t)ret[2]);
     return colortype(ret[0], ret[1], ret[2]);  // return CRGB((float)(color.r * fbright), (float)(color.g * fbright), (float)(color.b * fbright));
 }
-colortype neopixelstrip::desaturate(colortype color, int32_t _desat_of_ten) {  // desat_pc=0 has no effect, =10 desaturates all the way to greyscale, =-99 saturates to max. without change in brightness
+colortype NeopixelStrip::desaturate(colortype color, int32_t _desat_of_ten) {  // desat_pc=0 has no effect, =10 desaturates all the way to greyscale, =-99 saturates to max. without change in brightness
     uint8_t rgb[3] = { static_cast<uint8_t>(color.R), static_cast<uint8_t>(color.G), static_cast<uint8_t>(color.B) };
     float dominant = maxelement(rgb[0], rgb[1], rgb[2]);
     if (_desat_of_ten > 0)
@@ -133,13 +133,13 @@ colortype neopixelstrip::desaturate(colortype color, int32_t _desat_of_ten) {  /
     // }
     return colortype(rgb[0], rgb[1], rgb[2]);
 }
-colortype neopixelstrip::hue_to_rgb(uint8_t hue) {
+colortype NeopixelStrip::hue_to_rgb(uint8_t hue) {
     uint32_t rgb[3] = { 255 - 3 * (uint32_t)((255 - hue) % 85), 0, 3 * (uint32_t)((255 - hue) % 85) };
     if (hue <= 85) { rgb[1] = rgb[0]; rgb[0] = rgb[2]; rgb[2] = 0; }
     else if (hue <= 170) { rgb[1] = rgb[2]; rgb[2] = rgb[0]; rgb[0] = 0; }
     return colortype(rgb[0], rgb[1], rgb[2]);
 }
-void neopixelstrip::recolor_idiots(int8_t argidiot) {  // pass in -1 to recolor all idiots
+void NeopixelStrip::recolor_idiots(int8_t argidiot) {  // pass in -1 to recolor all idiots
     int8_t start = (argidiot >= 0) ? argidiot : 0;
     int8_t end = (argidiot >= 0) ? argidiot + 1 : idiotcount;
     for (int8_t idiot = start; idiot < end; idiot++) {
@@ -149,7 +149,7 @@ void neopixelstrip::recolor_idiots(int8_t argidiot) {  // pass in -1 to recolor
         cidiot[idiot][coff] = desaturate(cidiot[idiot][coff], desat_of_ten);
     }
 }
-void neopixelstrip::refresh() {
+void NeopixelStrip::refresh() {
     int32_t numledstowrite = (heartbeatNow != neostrip[0]);
     neostrip[0] = heartbeatNow;
     neoobj.SetPixelColor(0, heartbeatNow);
@@ -162,7 +162,7 @@ void neopixelstrip::refresh() {
     }
     if (numledstowrite) neoobj.Show(numledstowrite);  // This ability to exclude pixels at the end of the strip that haven't changed from the data write is an advantage of neopixelbus over adafruit
 }
-void neopixelstrip::init(uint8_t argpin, bool argbreadboard, bool viewcontext) {
+void NeopixelStrip::init(uint8_t argpin, bool argbreadboard, bool viewcontext) {
     pin = argpin;
     breadboard = argbreadboard;
     context = viewcontext;
@@ -177,10 +177,10 @@ void neopixelstrip::init(uint8_t argpin, bool argbreadboard, bool viewcontext) {
     refresh();
     std::cout << std::endl;
 }
-void neopixelstrip::calc_lobright() {
+void NeopixelStrip::calc_lobright() {
     lobright = smax(3, (hibright / lomultiplier) / lomultiplier);
 }
-void neopixelstrip::setbright(uint8_t bright_pc) {  // a way to specify brightness level as a percent
+void NeopixelStrip::setbright(uint8_t bright_pc) {  // a way to specify brightness level as a percent
     hibright = (uint8_t)((255.0 * (float)bright_pc) / 100.0);
     calc_lobright();
     if (neo_heartbeat_variable_brightness) {
@@ -189,21 +189,21 @@ void neopixelstrip::setbright(uint8_t bright_pc) {  // a way to specify brightne
     }
     recolor_idiots();
 }
-void neopixelstrip::setdesaturation(float _desat_of_ten) {  // a way to specify nite or daytime brightness levels
+void NeopixelStrip::setdesaturation(float _desat_of_ten) {  // a way to specify nite or daytime brightness levels
     desat_of_ten = _desat_of_ten;
     recolor_idiots();
 }
-void neopixelstrip::heartbeat(bool onoroff) {
+void NeopixelStrip::heartbeat(bool onoroff) {
     neo_heartbeat = onoroff;  // Start heart beating
 }
-void neopixelstrip::set_heartcolor(uint16_t newcolor) {
+void NeopixelStrip::set_heartcolor(uint16_t newcolor) {
     if (heartcolor16 != newcolor) {
         heartbeatColor = color_to_Rgb(newcolor);
         heartcolor_change = true;
         heartcolor16 = newcolor;
     }
 }
-void neopixelstrip::heartbeat_update() {
+void NeopixelStrip::heartbeat_update() {
     if (!neo_heartbeat) return;
     if (neoHeartbeatTimer.expired()) {
         heartbeat_pulse = !heartbeat_pulse;
@@ -224,16 +224,16 @@ void neopixelstrip::heartbeat_update() {
         neobright_last = heartbeat_brightness;
     }
 }
-void neopixelstrip::colorfade_update() {
+void NeopixelStrip::colorfade_update() {
     if (neoFadeTimer.expireset()) {
         heartbeatNow = hue_to_rgb(++neo_wheelcounter);
         neoobj.SetPixelColor(0, heartbeatNow);
     }
 }
-uint32_t neopixelstrip::neopixelsAvailable() {
+uint32_t NeopixelStrip::neopixelsAvailable() {
     return idiotcount;
 }
-bool neopixelstrip::newIdiotLight(uint8_t idiot, uint16_t color565, bool startboolstate) {
+bool NeopixelStrip::newIdiotLight(uint8_t idiot, uint16_t color565, bool startboolstate) {
     if (idiot > idiotcount-1) return false;
     fset[idiot][onoff] = startboolstate;
     cidiot[idiot][cnormal] = color_to_Rgb(color565);
@@ -244,18 +244,18 @@ bool neopixelstrip::newIdiotLight(uint8_t idiot, uint16_t color565, bool startbo
     recolor_idiots(idiot);
     return true;
 }
-void neopixelstrip::setBoolState(uint8_t idiot, bool state) {
+void NeopixelStrip::setBoolState(uint8_t idiot, bool state) {
     fset[idiot][onoff] = state;
 }
-bool neopixelstrip::fevpop(uint8_t idiot, int8_t pop_off) {
+bool NeopixelStrip::fevpop(uint8_t idiot, int8_t pop_off) {
     int8_t page = pop_off / 32;
     return (fevents[idiot][page] >> (pop_off - 32 * page)) & 1;  // pop a bit off the stack and return it
 }
-void neopixelstrip::fevpush(uint8_t idiot, int8_t push_off, bool push_val) {
+void NeopixelStrip::fevpush(uint8_t idiot, int8_t push_off, bool push_val) {
     int8_t page = push_off / 32;
     fevents[idiot][page] |= (push_val << (push_off - 32 * page));
 }
-void neopixelstrip::setflash(uint8_t idiot, uint8_t count, uint8_t pulseh, uint8_t pulsel, int32_t onbrit, int32_t color) {
+void NeopixelStrip::setflash(uint8_t idiot, uint8_t count, uint8_t pulseh, uint8_t pulsel, int32_t onbrit, int32_t color) {
     fset[idiot][fcount] = count;
     fset[idiot][fpulseh] = smax(pulseh, 1);
     fset[idiot][fpulsel] = smax(pulsel, 1);
@@ -278,16 +278,16 @@ void neopixelstrip::setflash(uint8_t idiot, uint8_t count, uint8_t pulseh, uint8
         filled = fevresolution / reps;
     }
 }
-uint32_t neopixelstrip::idiot_neo_color(uint8_t idiot) { 
+uint32_t NeopixelStrip::idiot_neo_color(uint8_t idiot) { 
     return color_to_32b(cidiot[idiot][cnow]);
 }
-void neopixelstrip::update_idiot(uint32_t idiot) {
+void NeopixelStrip::update_idiot(uint32_t idiot) {
     cidiot[idiot][clast] = cidiot[idiot][cnow];
     colortype newnow = (fset[idiot][onoff]) ? cidiot[idiot][con] : cidiot[idiot][coff];
     if (!fset[idiot][fcount]) cidiot[idiot][cnow] = newnow;
     else cidiot[idiot][cnow] = fevpop(idiot, nowepoch) ? cidiot[idiot][cflash] : newnow;
 }
-void neopixelstrip::update(bool blackout) {
+void NeopixelStrip::update(bool blackout) {
     heartbeat_update();  // Update our beating heart
     nowtime_us = (uint32_t)flashtimer.elapsed();
     nowepoch = nowtime_us / fquantum_us;
diff --git a/CANTroller2/src/qpid.h b/CANTroller2/src/qpid.h
index 39fd28e..522f477 100644
--- a/CANTroller2/src/qpid.h
+++ b/CANTroller2/src/qpid.h
@@ -4,7 +4,7 @@
 // QPID Library for Arduino - Version 3.1.9 by dlloydev https://github.com/Dlloydev/QPID
 // Based on the Arduino PID_v1 Library. Licensed under the MIT License.
 
-class qpid {
+class QPID {
   public:
     enum class ctrl : uint8_t {manual, automatic, toggle};            // controller mode
     enum class cdir : uint8_t {direct, reverse};                      // controller direction
@@ -24,42 +24,42 @@ class qpid {
     centmod _centmode = centmod::off;  // Soren
     uint32_t sampletime, lasttime;
   public:
-    qpid() {}  // Default constructor
-    qpid(float* __in, float __min, float __max, float __kp = 0, float __ki = 0, float __kd = 0,  // Soren edit
-      pmod __pmode = pmod::onerr, dmod __dmode = dmod::onmeas, awmod __awmode = awmod::cond, cdir __dir = cdir::direct,
-      uint32_t __sampletime = 100000, ctrl __mode = ctrl::manual, centmod __centmode = centmod::off, float __cent = NAN) {
-        init(__in, __min, __max, __kp, __ki, __kd, __pmode, __dmode, __awmode, __dir, __sampletime, __mode, __centmode, __cent);
+    QPID() {}  // Default constructor
+    QPID(float* a_in, float a_min, float a_max, float a_kp = 0, float a_ki = 0, float a_kd = 0,  // Soren edit
+      pmod a_pmode = pmod::onerr, dmod a_dmode = dmod::onmeas, awmod a_awmode = awmod::cond, cdir a_dir = cdir::direct,
+      uint32_t a_sampletime = 100000, ctrl a_mode = ctrl::manual, centmod a_centmode = centmod::off, float a_cent = NAN) {
+        init(a_in, a_min, a_max, a_kp, a_ki, a_kd, a_pmode, a_dmode, a_awmode, a_dir, a_sampletime, a_mode, a_centmode, a_cent);
     }
-    void init(float* __in, float __min, float __max, float __kp = 0, float __ki = 0, float __kd = 0,  // Soren edit
-        pmod __pmode = pmod::onerr, dmod __dmode = dmod::onmeas, awmod __awmode = awmod::cond, cdir __dir = cdir::direct,
-        uint32_t __sampletime = 100000, ctrl __mode = ctrl::manual, centmod __centmode = centmod::off, float __cent = NAN);
-    void set_mode(ctrl __mode);
-    void set_mode(uint8_t __mode);
+    void init(float* a_in, float a_min, float a_max, float a_kp = 0, float a_ki = 0, float a_kd = 0,  // Soren edit
+        pmod a_pmode = pmod::onerr, dmod a_dmode = dmod::onmeas, awmod a_awmode = awmod::cond, cdir a_dir = cdir::direct,
+        uint32_t a_sampletime = 100000, ctrl a_mode = ctrl::manual, centmod a_centmode = centmod::off, float a_cent = NAN);
+    void set_mode(ctrl a_mode);
+    void set_mode(uint8_t a_mode);
     float compute();  // Performs the PID calculation
-    void set_outlimits(float __min, float __max);  // Sets and clamps the output to a specific range (0-255 by default).
-    void set_centmode(centmod __centmode);  // Soren
-    void set_centmode(uint8_t __centmode);  // Soren
-    void set_cent(float __cent);  // Soren
-    void set_tunings(float __kp, float __ki, float __kd);
-    void set_tunings(float __kp, float __ki, float __kd, pmod __pmode, dmod __dmode, awmod __awmode);
-    void set_kp(float __kp);
-    void set_ki(float __ki);
-    void set_kd(float __kd);
-    void add_kp(float __kp);
-    void add_ki(float __ki);
-    void add_kd(float __kd);
-    void set_dir(cdir __dir);
-    void set_dir(uint8_t __dir);
-    void set_sampletime(uint32_t __sampletime);  // in microseconds
-    void set_pmode(pmod __pmode);  // Sets the computation method for the proportional term, to compute based either on error (default), on measurement, or the average of both.
-    void set_pmode(uint8_t __pmode);
-    void set_dmode(dmod __dmode);  // Sets the computation method for the derivative term, to compute based either on error or measurement (default).
-    void set_dmode(uint8_t __dmode);
-    void set_awmode(awmod __awmode);  // Sets the integral anti-windup mode to one of awClamp, which clamps the output after adding integral and proportional (on measurement) terms, or awcond (default), which provides some integral correction, prevents deep saturation and reduces overshoot. Option awOff disables anti-windup altogether.
-    void set_awmode(uint8_t __awmode);
-    void set_outsum(float __outsum);  // sets the output summation value
-    void set_target(float __target);
-    void set_output(float __output);
+    void set_outlimits(float a_min, float a_max);  // Sets and clamps the output to a specific range (0-255 by default).
+    void set_centmode(centmod a_centmode);  // Soren
+    void set_centmode(uint8_t a_centmode);  // Soren
+    void set_cent(float a_cent);  // Soren
+    void set_tunings(float a_kp, float a_ki, float a_kd);
+    void set_tunings(float a_kp, float a_ki, float a_kd, pmod a_pmode, dmod a_dmode, awmod a_awmode);
+    void set_kp(float a_kp);
+    void set_ki(float a_ki);
+    void set_kd(float a_kd);
+    void add_kp(float a_kp);
+    void add_ki(float a_ki);
+    void add_kd(float a_kd);
+    void set_dir(cdir a_dir);
+    void set_dir(uint8_t a_dir);
+    void set_sampletime(uint32_t a_sampletime);  // in microseconds
+    void set_pmode(pmod a_pmode);  // Sets the computation method for the proportional term, to compute based either on error (default), on measurement, or the average of both.
+    void set_pmode(uint8_t a_pmode);
+    void set_dmode(dmod a_dmode);  // Sets the computation method for the derivative term, to compute based either on error or measurement (default).
+    void set_dmode(uint8_t a_dmode);
+    void set_awmode(awmod a_awmode);  // Sets the integral anti-windup mode to one of awClamp, which clamps the output after adding integral and proportional (on measurement) terms, or awcond (default), which provides some integral correction, prevents deep saturation and reduces overshoot. Option awOff disables anti-windup altogether.
+    void set_awmode(uint8_t a_awmode);
+    void set_outsum(float a_outsum);  // sets the output summation value
+    void set_target(float a_target);
+    void set_output(float a_output);
     void init();        // Ensure a bumpless transfer from manual to automatic mode
     void reset();             // Clears _pterm, _iterm, _dterm and _outsum values
     // Getter functions
@@ -85,26 +85,26 @@ class qpid {
     uint8_t centmode() { return static_cast<uint8_t>(_centmode); }  // Soren
     float* target_ptr() { return &_target; }
 };
-void qpid::init(float* __in, float __min, float __max, float __kp, float __ki, float __kd, pmod __pmode, dmod __dmode,
-  awmod __awmode, cdir __dir, uint32_t __sampletime, ctrl __mode, centmod __centmode, float __cent) {  // Soren edit
-    myin = __in;
-    _mode = __mode;
-    qpid::set_outlimits(__min, __max);  // same default as Arduino PWM limit - Soren edit
-    qpid::set_centmode(__centmode);  // Soren
-    if (_centmode != centmod::off && !std::isnan(__cent)) {  // Soren
-        set_cent(__cent);  // Soren
+void QPID::init(float* a_in, float a_min, float a_max, float a_kp, float a_ki, float a_kd, pmod a_pmode, dmod a_dmode,
+  awmod a_awmode, cdir a_dir, uint32_t a_sampletime, ctrl a_mode, centmod a_centmode, float a_cent) {  // Soren edit
+    myin = a_in;
+    _mode = a_mode;
+    QPID::set_outlimits(a_min, a_max);  // same default as Arduino PWM limit - Soren edit
+    QPID::set_centmode(a_centmode);  // Soren
+    if (_centmode != centmod::off && !std::isnan(a_cent)) {  // Soren
+        set_cent(a_cent);  // Soren
         _outsum = _cent;
     }
     else set_cent(_outmin);  // Soren
-    sampletime = __sampletime;              // Soren edit
-    qpid::set_dir(__dir);
-    qpid::set_tunings(__kp, __ki, __kd, _pmode, _dmode, _awmode);
+    sampletime = a_sampletime;              // Soren edit
+    QPID::set_dir(a_dir);
+    QPID::set_tunings(a_kp, a_ki, a_kd, _pmode, _dmode, _awmode);
     lasttime = micros() - sampletime;  // Soren edit
 }
 
 // This function should be called every time "void loop()" executes. The function will decide whether a new 
 // PID output needs to be computed. Returns true when the output is computed, false when nothing has been done.
-float qpid::compute() {
+float QPID::compute() {
     uint32_t now = micros();  // Soren edit
     uint32_t timechange = (now - lasttime);
     if (_mode == ctrl::automatic && timechange < sampletime) return _output;  // If class is handling the timing and this time was a nop
@@ -156,99 +156,99 @@ float qpid::compute() {
 
 // set_tunings  This function allows the controller's dynamic performance to be adjusted. It's called 
 // automatically from the constructor, but tunings can also be adjusted on the fly during normal operation.
-void qpid::set_tunings(float __kp, float __ki, float __kd, pmod __pmode = pmod::onerr,
-    dmod __dmode = dmod::onmeas, awmod __awmode = awmod::cond) {
-    if (__kp < 0 || __ki < 0 || __kd < 0 || !sampletime) return;  // Soren - added divide by zero protection
-    if (__ki == 0) _outsum = 0;
-    _pmode = __pmode; _dmode = __dmode; _awmode = __awmode;
-    dispkp = __kp; dispki = __ki; dispkd = __kd;
+void QPID::set_tunings(float a_kp, float a_ki, float a_kd, pmod a_pmode = pmod::onerr,
+    dmod a_dmode = dmod::onmeas, awmod a_awmode = awmod::cond) {
+    if (a_kp < 0 || a_ki < 0 || a_kd < 0 || !sampletime) return;  // Soren - added divide by zero protection
+    if (a_ki == 0) _outsum = 0;
+    _pmode = a_pmode; _dmode = a_dmode; _awmode = a_awmode;
+    dispkp = a_kp; dispki = a_ki; dispkd = a_kd;
     float sampletime_sec = (float)sampletime / 1000000;
-    _kp = __kp;
-    _ki = __ki * sampletime_sec;
-    _kd = __kd / sampletime_sec;
+    _kp = a_kp;
+    _ki = a_ki * sampletime_sec;
+    _kd = a_kd / sampletime_sec;
 }
 
 // set_tunings  Set Tunings using the last remembered pmode, dmode and awmode settings.
-void qpid::set_tunings(float __kp, float __ki, float __kd) {
-    set_tunings(__kp, __ki, __kd, _pmode, _dmode, _awmode);
+void QPID::set_tunings(float a_kp, float a_ki, float a_kd) {
+    set_tunings(a_kp, a_ki, a_kd, _pmode, _dmode, _awmode);
 }
 
 // Soren: I wrote these to facilitate changing only one tuning parameter at a time
-void qpid::set_kp(float __kp) { set_tunings(__kp, dispki, dispkd, _pmode, _dmode, _awmode); }  // Soren
-void qpid::set_ki(float __ki) { set_tunings(dispkp, __ki, dispkd, _pmode, _dmode, _awmode); }  // Soren
-void qpid::set_kd(float __kd) { set_tunings(dispkp, dispki, __kd, _pmode, _dmode, _awmode); }  // Soren
+void QPID::set_kp(float a_kp) { set_tunings(a_kp, dispki, dispkd, _pmode, _dmode, _awmode); }  // Soren
+void QPID::set_ki(float a_ki) { set_tunings(dispkp, a_ki, dispkd, _pmode, _dmode, _awmode); }  // Soren
+void QPID::set_kd(float a_kd) { set_tunings(dispkp, dispki, a_kd, _pmode, _dmode, _awmode); }  // Soren
 
-void qpid::add_kp(float add) { set_kp(_kp + add); }  // Soren
-void qpid::add_ki(float add) { set_ki(_ki + add); }  // Soren
-void qpid::add_kd(float add) { set_kd(_kd + add); }  // Soren
+void QPID::add_kp(float add) { set_kp(_kp + add); }  // Soren
+void QPID::add_ki(float add) { set_ki(_ki + add); }  // Soren
+void QPID::add_kd(float add) { set_kd(_kd + add); }  // Soren
 
 // set_sampletime  Sets the period, in microseconds, at which the calculation is performed.
-void qpid::set_sampletime(uint32_t __sampletime) {
-    if (__sampletime > 0 && sampletime) {  // Soren - added more divide by zero protection
-        float ratio  = (float)__sampletime / (float)sampletime;
+void QPID::set_sampletime(uint32_t a_sampletime) {
+    if (a_sampletime > 0 && sampletime) {  // Soren - added more divide by zero protection
+        float ratio  = (float)a_sampletime / (float)sampletime;
         _ki *= ratio;
         _kd /= ratio;
-        sampletime = __sampletime;
+        sampletime = a_sampletime;
     }
 }
 
 // set_outLimits  The PID controller is designed to vary its output within a given range, default 0-255
-void qpid::set_outlimits(float __min, float __max) {
-    if (__min >= __max) return;
-    _outmin = __min; _outmax = __max;
+void QPID::set_outlimits(float a_min, float a_max) {
+    if (a_min >= a_max) return;
+    _outmin = a_min; _outmax = a_max;
 
     // if (_mode != ctrl::manual) {
     _output = constrain(_output, _outmin, _outmax);  // Soren
     _outsum = constrain(_outsum, _outmin, _outmax);
 }
 
-void qpid::set_centmode(centmod __centmode) { _centmode = __centmode; }  // Soren
-void qpid::set_centmode(uint8_t __centmode) { _centmode = (centmod)__centmode; }  // Soren
-void qpid::set_cent(float __cent) { if (_outmin <= __cent && _outmax >= __cent) _cent = __cent; }  // Soren
-void qpid::set_target(float __target) { _target = __target; }
-void qpid::set_output(float __output) { _output = constrain(__output, _outmin, _outmax); }
+void QPID::set_centmode(centmod a_centmode) { _centmode = a_centmode; }  // Soren
+void QPID::set_centmode(uint8_t a_centmode) { _centmode = (centmod)a_centmode; }  // Soren
+void QPID::set_cent(float a_cent) { if (_outmin <= a_cent && _outmax >= a_cent) _cent = a_cent; }  // Soren
+void QPID::set_target(float a_target) { _target = a_target; }
+void QPID::set_output(float a_output) { _output = constrain(a_output, _outmin, _outmax); }
 
 // set_mode Sets the controller mode to manual (0), automatic (1) or timer (2) when the transition 
 // from manual to automatic or timer occurs, the controller is automatically initialized.
-void qpid::set_mode(ctrl __mode) {
-    if (_mode == ctrl::manual && __mode != ctrl::manual) { // just went from manual to automatic
+void QPID::set_mode(ctrl a_mode) {
+    if (_mode == ctrl::manual && a_mode != ctrl::manual) { // just went from manual to automatic
         _mode = ctrl::automatic;
-        qpid::init();
+        QPID::init();
     }
-    else if (_mode == ctrl::automatic && __mode != ctrl::automatic) {
+    else if (_mode == ctrl::automatic && a_mode != ctrl::automatic) {
         _mode = ctrl::manual;
     }
 }
-void qpid::set_mode(uint8_t __mode) { set_mode((ctrl)__mode); }
+void QPID::set_mode(uint8_t a_mode) { set_mode((ctrl)a_mode); }
 
 // Does all the things that need to happen to ensure a bumpless transfer from manual to automatic mode.
-void qpid::init() {
+void QPID::init() {
     _outsum = _output;  // Soren
     lastin = *myin;
     _outsum = constrain(_outsum, _outmin, _outmax);
 }
 
 // The PID will either be connected to a direct acting process (+output leads to +input) or a reverse acting process(+output leads to -input).
-void qpid::set_dir(cdir __dir) { _dir = __dir; }
-void qpid::set_dir(uint8_t __dir) { _dir = (cdir)__dir; }
+void QPID::set_dir(cdir a_dir) { _dir = a_dir; }
+void QPID::set_dir(uint8_t a_dir) { _dir = (cdir)a_dir; }
 
 // Sets the computation method for the proportional term, to compute based either on error (default), on measurement, or the average of both.
-void qpid::set_pmode(pmod __pmode) { _pmode = __pmode; }
-void qpid::set_pmode(uint8_t __pmode) { _pmode = (pmod)__pmode; }
+void QPID::set_pmode(pmod a_pmode) { _pmode = a_pmode; }
+void QPID::set_pmode(uint8_t a_pmode) { _pmode = (pmod)a_pmode; }
 
 // Sets the computation method for the derivative term, to compute based either on error or on measurement (default).
-void qpid::set_dmode(dmod __dmode) { _dmode = __dmode; }
-void qpid::set_dmode(uint8_t __dmode) { _dmode = (dmod)__dmode; }
+void QPID::set_dmode(dmod a_dmode) { _dmode = a_dmode; }
+void QPID::set_dmode(uint8_t a_dmode) { _dmode = (dmod)a_dmode; }
 
 // Sets the integral anti-windup mode to one of clamp, which clamps the output after adding integral and proportional (on measurement) terms,
 // or cond (default), which provides some integral correction, prevents deep saturation and reduces overshoot. Option off disables anti-windup altogether.
-void qpid::set_awmode(awmod __awmode) { _awmode = __awmode; }
-void qpid::set_awmode(uint8_t __awmode) { _awmode = (awmod)__awmode; }
+void QPID::set_awmode(awmod a_awmode) { _awmode = a_awmode; }
+void QPID::set_awmode(uint8_t a_awmode) { _awmode = (awmod)a_awmode; }
 
-void qpid::reset() {
+void QPID::reset() {
     lasttime = micros() - sampletime;  // Soren edit
     lastin = 0; _outsum = 0;
     _pterm = 0; _iterm = 0; _dterm = 0;
 }
 // sets the output summation value
-void qpid::set_outsum(float __outsum) { _outsum = __outsum; }
+void QPID::set_outsum(float a_outsum) { _outsum = a_outsum; }
diff --git a/CANTroller2/src/uictrl.h b/CANTroller2/src/uictrl.h
index a11c431..4f526c6 100644
--- a/CANTroller2/src/uictrl.h
+++ b/CANTroller2/src/uictrl.h
@@ -56,7 +56,6 @@ class Encoder {
         int32_t _state = 0;
         int32_t _sw_action = NONE;  // Flag for encoder handler to know an encoder switch action needs to be handled
         uint32_t _spinrate_us = 1000000;  // How many us elapsed between the last two encoder detents? realistic range while spinning is 5 to 100 ms I'd guess
-        bool _sw = false;  // Remember whether switch is being pressed
         bool _timer_active = false;  // Flag to prevent re-handling long presses if the sw is just kept down
         bool _suppress_click = false;  // Flag to prevent a short click on switch release after successful long press
         Timer _spinspeedTimer;  // Used to figure out how fast we're spinning the knob.  OK to not be volatile?
@@ -83,7 +82,8 @@ class Encoder {
         }
 
     public:
-        enum sw_presses { NONE, SHORT, LONG };
+        enum sw_presses : int { NONE, SHORT, LONG };
+        bool sw = false;  // Remember whether switch is being pressed
 
         Encoder(uint8_t a, uint8_t b, uint8_t sw) : _a_pin(a), _b_pin(b), _sw_pin(sw), _longPressTimer(_longPressTime){}
         Encoder() = delete; // must be instantiated with pins
@@ -104,7 +104,7 @@ class Encoder {
             // Encoder handler routines should act whenever encoder_sw_action is SHORT or LONG, setting it back to
             // NONE once handled. When handling press, if encoder_long_clicked is nonzero then press is a long press
             if (!read_pin(_sw_pin)) {  // if encoder sw is being pressed (switch is active low)
-                if (!_sw) {  // if the press just occurred
+                if (!sw) {  // if the press just occurred
                     _longPressTimer.reset();  // start a press timer
                     _timer_active = true;  // flag to indicate timing for a possible long press
                 }
@@ -113,17 +113,17 @@ class Encoder {
                     _timer_active = false;  // Keeps us from entering this logic again until after next sw release (to prevent repeated long presses)
                     _suppress_click = true;  // Prevents the switch release after a long press from causing a short press
                 }
-                _sw = true;  // Remember a press is in effect
+                sw = true;  // Remember a press is in effect
             }
             else {  // if encoder sw is not being pressed
-                if (_sw && !_suppress_click) _sw_action = SHORT;  // if the switch was just released, a short press occurred, which must be handled
+                if (sw && !_suppress_click) _sw_action = SHORT;  // if the switch was just released, a short press occurred, which must be handled
                 _timer_active = false;  // Allows detection of next long press event
-                _sw = false;  // Remember press is not in effect
+                sw = false;  // Remember press is not in effect
                 _suppress_click = false;  // End click suppression
             }
         }
         bool pressed() {
-            return _sw;
+            return sw;
         }
         uint32_t press_event(bool autoreset = true) {
             uint32_t ret = _sw_action;
diff --git a/CANTroller2/src/unittests.h b/CANTroller2/src/unittests.h
index 9b36f60..c937be5 100644
--- a/CANTroller2/src/unittests.h
+++ b/CANTroller2/src/unittests.h
@@ -2,8 +2,8 @@
 /* Contains unit tests */
 #pragma once
 #include <cassert>  // for assert
-// #include "sensors.h"
-// #include <memory>
+#include "sensors.h"
+#include <memory>
 
 void test_Param() {
     // default constructor
